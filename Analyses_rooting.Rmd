--- 
title: 'Development of an *in vitro* method of propagation using growth regulators for Basin Big sagebrush (*Artemisia tridentata* subsp. *tridentata*: 2n=2x=18) to support genome sequencing and GxE research'
author: "Rachael Barron, Peggy Martinez, Marcelo Serpe, Sven Buerki"
output:
  bookdown::html_document2: 
    toc: TRUE
    toc_float: TRUE
link-citations: yes
fontsize: 12pt
bibliography: packages.bib
---

```{r packages, echo=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(rmarkdown)
library(bookdown)
#library(distill)
library(knitcitations)
library(formatR)
library(devtools)
library(gplots)
library(RColorBrewer)
library(grDevices)
library(pscl)
library(lmtest)
library(lsmeans)
library(emmeans)
library(DT)

#Generate BibTex citation file for all R packages used to produce report
knitr::write_bib(.packages(), file = 'packages.bib')
```


```{r setup, include=FALSE, cache=FALSE, message = FALSE}
#Load packages
library(knitr)
library(rmarkdown)
# Chunk options: see http://yihui.name/knitr/options/ ###

## Text results
opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE, include = TRUE)

## Code decoration
#opts_chunk$set(tidy = TRUE, R.options = list(width = 60), highlight = TRUE)

## Caching code
opts_chunk$set(cache = 2, cache.path = "cache/")

## Plots
#opts_chunk$set(fig.path = "Figures_MS/", dev=c('pdf', 'png'), dpi = 300)

## Locate figures as close as possible to requested position (=code)
#opts_chunk$set(fig.pos = "H")
```

# Reproducible workflow: integrating code, data, methods and key outcomes

This document is associated to Barron et al. and provides the reproducible workflow integrating data, code, methods and results associated to this study. 

Citations of `R` packages required to conduct this research and produce this document are provided in [Appendix 1]. Version information about `R`, the operating system (OS) and attached or `R` loaded packages are available in [Appendix 2]. The data underpinning this study are deposited on [GitHub](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop). Appendices together with the data and R code presented in this document should allow reproducibility of this study.

# Overview of methodology 

In this document, we are presenting the code associated to the analyses performed on tissue culture data (rooting and calli) generated from shoot tips of diploid *Artemisia tridentata* subsp. *tridentata* (2n=2x=18). 

The analyses were conducted in four steps:

- **Step 1:** Import and tidy raw data.
- **Step 2:** Preliminary analyses on the effect of growth regulators on rooting and calli development on shoot tips.
- **Step 3:** Comparative analyses on tissue culture data. This was done following a two-tier approach:
  + Statistical analyses (test for normality and conduct ANOVAs and multiple pairwise-comparison tests with *p*-value <= 0.01).
  + Clustering analyses.
- **Step 4:** *In vitro* growth of plantules. 
  + Assessing the effect of growth regulators and rooting clusters on plantule survival and growth rates.


# Step 1: Import and tidy raw data

The objective of this section is to merge data on rooting and calli stored in spreadsheets (in `csv` format). Each spreadsheet corresponds to a block and the code below collate these into one `data.frame` for downstream analyses. 

The final dataset (`MERGE` object) contains the following columns (see Table \@ref(tab:tidy) for more details on sampling):

- `Block`: 1 to 5.
- `Treatment`: `Control` (= no growth regulator), `IBA_1`, `IBA_05`, `NAA_1`, `NAA_05`. Here `1` and `05` represent concentrations of the two growth regulators (IBA and NAA) at 1 and 0.5 mg/l. 
- `Replicate`: 1 to 3.
- `Genotype`: `G1` and `G2`.
- Individual: `Individual` and `IndGeno`. The latter variable combines data on genotype and individual and will be used throughout the document.
- `Callus`: Binary (1/0).
- Root: `Root` with number of roots per shoot tip and `RootBin` with binary (1/0) data. Although statistical analyses were also performed on binary data, analyses are mainly based on the quantitative variable (= `Root`).

## Code to import and tidy raw data

Raw data in `csv` format are stored in the `01_Raw_data` folder. The processed/tidy data are saved in `csv` format in the `02_Processed_data` folder. The `MERGE` object (in class `data.frame`) will be used for downstream analyses.

```{r tidy1, echo=TRUE, eval=TRUE}
###~~
#List all csv files (raw data from blocks)
###~~~

#Raw data are stored in the 01_Raw_Data folder
csv <- list.files(path = "01_Raw_Data", pattern='block.csv', full.names = T)

#Print names of csv files
print(csv)

#Rm processed files
toRm <- grep("Processed_", csv)
if(length(toRm) > 0){
  csv <- csv[-toRm]
}

###~~~
#Execute loop to process all files and merge them (see below)
###~~~
# Empty object that will contain all processed data
# Save processed data into 02_Processed_data folder
MERGE <- NULL
for(i in 1:length(csv)){
  ###
  #Read in sv file
  mat <- read.csv(csv[i])
  
  ###~~~
  #Create final matrix
  ###~~~
  
  #List of individuals
  indcsv <- LETTERS[seq( from = 1, to = 9 )]
  
  #Empty matrix
  FINALmat <- data.frame(matrix(ncol=7, nrow = nrow(mat)*length(indcsv)))
  colnames(FINALmat) <- c("Block","Treatment", "Replicate", "Genotype", "Individual", "Callus", "Root")
  
  ###~~~
  #Start populating FINALmat 
  ###~~~
  # Add Block, Treatment and Replicates
  #Get data for block, treatment (and replicates)
  blockTreatRep <- rep(as.vector(mat$X), 9)
  FINALmat$Block <- sapply(strsplit(blockTreatRep, split='_'), "[", 1)
  FINALmat$Treatment <- paste(sapply(strsplit(blockTreatRep, split='_'), "[", 2), sapply(strsplit(blockTreatRep, split='_'), "[", 3), sep='_')
  FINALmat$Replicate <- sapply(strsplit(blockTreatRep, split='_'), "[", 4)
  
  #Deal with Controls
  contr <- grep("Control_", FINALmat$Treatment)
  FINALmat$Replicate[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",2)
  FINALmat$Treatment[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",1)
  
  ###~~~
  # Fetch individual data
  ###~~~
  
  #Where are ind in mat?
  indcol <- match(indcsv, colnames(mat))
  
  #Fetch raw data for each individual in block
  OUT <- NULL
  for(j in 1:length(indcol)){
    #Extract info for each individual
    tmp <- mat[,indcol[j]:(indcol[j]+2)]
    colnames(tmp) <- c("Ind", "Callus", "Root")
    OUT <- rbind(OUT, tmp)
  }
  
  ###~~~
  #Add OUT to FINALmat
  ###~~~
  
  #Genotypes
  FINALmat$Genotype <- sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 1)
  #Ind
  FINALmat$Individual <- paste(sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 2), sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 3), sep='_')
  #Callus
  FINALmat$Callus <- OUT$Callus
  #Root
  FINALmat$Root <- OUT$Root
  
  ###~~~
  #Save FINALmat
  ###~~~
  write.csv(FINALmat, file=paste0("02_Processed_data/Processed_", strsplit(csv[i], split="/")[[1]][2]), row.names = F, quote = F)
  
  ###~~~
  #MERGE all csv
  ###~~~
  MERGE <- rbind(MERGE, FINALmat)
  
}

###~~~
#Finalize preping of the data
###~~~
# Add a binary rooting col
MERGE <- data.frame(MERGE)

MERGE$IndGeno <- paste(MERGE$Genotype, MERGE$Individual, sep="_")

#Create a binary for Root
MERGE$RootBin <- MERGE$Root
MERGE$RootBin[MERGE$RootBin > 0] <- 1

###~~~
#Save MERGED files with all blocks
###~~~
# Save processed data into 02_Processed_data folder
write.csv(MERGE, file=paste0("02_Processed_data/Processed_", "blocks_rooting.csv"), row.names = F, quote = F)

#Return head of MERGE (see Appendix for more details)
head(MERGE)
```

## Statistics on plant materials 

Table \@ref(tab:statssampling) provides a summary of plant materials included in this study. Overall, 45 individuals distributed into two genotypes (which were evenly sampled) were generated from seeds. For each individual, 15 shoot tips were produced and included into five treatments with three replicates (= 3 shoot tips/ind./treatment). Individuals were randomly allocated to 5 blocks containing 9 individual each. The code below generates Table \@ref(tab:statssampling).

### Code to generate Table \@ref(tab:statssampling)

```{r statssampling, echo=TRUE, eval=TRUE}
#Create and populate table to summarize sampling (Table 1)
samp_mat <- matrix(ncol=9, nrow=1)
colnames(samp_mat) <- c("N. block", "N. treatments", "Treatments", "N. replicates", "N. genotypes", 
                        "N. individuals", "N. ind. per genotype", "Ind. G1", "Ind. G2")

#N block
samp_mat[,1] <- length(unique(MERGE$Block))
#N treat
samp_mat[,2] <- length(unique(MERGE$Treatment))
#Treat ID
samp_mat[,3] <- paste(sort(unique(MERGE$Treatment)), collapse = ", ")
#N replicates
samp_mat[,4] <- length(unique(MERGE$Replicate))
#N genotypes
samp_mat[,5] <- length(unique(MERGE$Genotype))
#N ind
samp_mat[,6] <- length(unique(MERGE$IndGeno))
#N ind per genotype
samp_mat[,7] <- paste(paste("G1:", list(table(MERGE$Genotype)/15)[[1]][1]), paste("G2:", list(table(MERGE$Genotype)/15)[[1]][2]), sep=', ')
#List ind G1
samp_mat[,8] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G1"))), collapse=', ')
#List ind G2
samp_mat[,9] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G2"))), collapse=', ')

#Write table
#write.csv(samp_mat, file="Table_1_sampling_summary.csv", row.names = F)

#Plot table
knitr::kable(samp_mat, caption = "Summary of sampling at the basis of sagebrush rooting experiment.")
```

# Step 2: Preliminary analyses on the effect of growth regulators on rooting and calli development on shoot tips

Preliminary data summarizing results of our experiments are provided here to assess the effect of growth regulators on *in vitro* rooting of *Artemisia tridentata*. During the course of the experiment, calli developed on a large proportion of shoot tips, which was unexpected based on preliminary data. We are therefore summarizing these data here by treatment and will devote a portion of the analyses to investigate whether callus development was associated to treatments and whether those inhibited or promoted rooting.

## Effect of growth regulators on *in vitro* callus development in *Artemisia tridentata*

The effect of growth regulators on calli development is provided in Table \@ref(tab:growthbyregulatorcallus) and compared to the control treatment (= no growth regulator). These data show contrasting calli development between the control and treatments including growth hormones. Control shoot tips had limited calli development, whereas responses for those undergoing treatments were very high (>70%; Table \@ref(tab:growthbyregulatorcallus)).

### Code to generate Table \@ref(tab:growthbyregulatorcallus)

```{r growthbyregulatorcallus, echo=T, eval=T}
#Matrix summarizing effect of growth regulators on rooting
CallusStatbyTreat <- matrix(ncol=3, nrow=5)
colnames(CallusStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)")
rownames(CallusStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
CallusStatbyTreat <- as.data.frame(CallusStatbyTreat)

#Populate matrix
CallusStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(CallusStatbyTreat), split="_"),"[[",1)
CallusStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(CallusStatbyTreat)[2:nrow(CallusStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(CallusStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(CallusStatbyTreat)[i])
  CallusStatbyTreat$`Response (%)`[i] <- paste(round(100*mean(foo$Callus),2), "+/-", round(sd(foo$Callus),2), sep = " ") 
}


#Plot table
knitr::kable(CallusStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro calli development on shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates (+/- standard deviation).")
```


## Effect of growth regulators on *in vitro* rooting of *Artemisia tridentata*

The effect of growth regulators is provided in Table \@ref(tab:growthbyregulator) and compared to the control treatment (= no growth regulator). These data show a very high level of variation in rooting (see column `Av. No. roots`). We are hypothesizing that this trend is caused by an individual effect. To test this hypothesis we will conduct comparative analyses (see **Step 4**) to sort individuals based on their rooting abilities. Finally, the effect of growth regulators on *in vitro* rooting will be compared within each cluster.  

### Code to generate Table \@ref(tab:growthbyregulator)

```{r growthbyregulator, echo=T, eval=T}
#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreat <- matrix(ncol=4, nrow=5)
colnames(RootingStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots")
rownames(RootingStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
RootingStatbyTreat <- as.data.frame(RootingStatbyTreat)

#Populate matrix
RootingStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(RootingStatbyTreat), split="_"),"[[",1)
RootingStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(RootingStatbyTreat)[2:nrow(RootingStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(RootingStatbyTreat)[i])
  RootingStatbyTreat$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep=" ")
  RootingStatbyTreat$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro rooting for shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates +/- standard deviation; Av. No. of roots (Average number of roots per shoot tip): mean +/- standard deviation.")
```

# Step 3: Comparative analyses

The input variables for these analyses are stored in `MERGE`.

## Statistical analyses on rooting data

Please find below the analyses conducted on quantitative rooting data (= counts of number of roots per shoot tip).

### Test for normality and best model

Before conducting statistical analyses, we have to test for normality of rooting data using the Shapiro-Wilk normality test implemented in the R base function `shapiro.test()`. A *p*-value <= 0.01 is will be used for significance.

```{r normalitytest, eval=T, echo=T}
#Conducting Shapiro-Wilk normality test on root data
Rootnorm <- shapiro.test(MERGE$Root)
print(Rootnorm)
```

The test strongly rejects normality of the rooting data. In this context, we aim at analyzing the data using general linear models (`glm`), but what is the best fitted family/model to describe the data distribution? Let's look at the distribution of the data (Figure \@ref(fig:distrRoot)):

```{r distrRoot, echo=T, eval=T, fig.cap="Distribution of number of roots per shoot tips"}
hist(MERGE$Root, xlab="Number of roots per shoot tip", main="")
```

Figure \@ref(fig:distrRoot) suggests that the Poisson model would best fit the data; however it is skewed towards zeros (with the highest frequency), which is problematic with classic `glm` models. In this context, we are advocating for using the zero-inflated count data regression approach as implemented in the `pscl` R package [@R-pscl] to analyze the rooting data. This approach fits zero-inflated regression models for count data via maximum likelihood. It is not recommended that zero-inflated Poisson models be applied to small samples (see [here](https://stats.idre.ucla.edu/r/dae/zip/)), which could prove problematic for our individual dataset.


### Investigate treatment effect

As shown in Figure \@ref(fig:distrRoot) we still need to test what model best fit the data. Here, we will be investigating whether treatment affect rooting using both the Poisson and Negative binary count model families. A likelihood ratio test together with dispersion statistics will be used to identify the best-fit model. 

```{r zeroinflRoot, echo=T, eval=T}
# Zero-Inflated Poisson GLM
M1 <- zeroinfl(Root ~ Treatment, dist = 'poisson', data = MERGE)

# Dispersion statistic for M1
E2 <- resid(M1, type = "pearson")
N  <- nrow(MERGE)
p  <- length(coef(M1))  
sum(E2^2) / (N - p)

# Zero-Inflated Negative Binomial GLM
M2 <- zeroinfl(Root ~ Treatment, dist = 'negbin', data = MERGE) 

# Dispersion statistic for M2
E2 <- resid(M2, type = "pearson")
N  <- nrow(MERGE)
p  <- length(coef(M2))  
sum(E2^2) / (N - p)

# Likelihood ratio test
lrtest(M1, M2)

# Summary of M2
summary(M2)
```

M2 is the best-fit model and it shows that there is a significant treatment effect in explaining rooting data. Before ranking treatments, we would like to rapidly test whether there is a genotype effect in explaining the rooting by amending M2. We will be investigating individual effect below.

```{r Genotype, eval=T, echo=T}
# Amending M2 to test for genotype effect

# Zero-Inflated Negative Binomial GLM
M3 <- zeroinfl(Root ~ Treatment + Genotype, dist = 'negbin', data = MERGE) 

# Summarize M3
summary(M3)
```

This model shows that there is no genotype effect in our data. we are then proceeding with pairwise comparison of treatments.

#### Ranking treatments

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansRoot, eval=T, echo=T}
# Estimated marginal means (Least-squares means) for treatments using M2
posthocRoot <- emmeans(M2, list(pairwise ~ Treatment))

# Identify significant pairwise comparisons
signRootTreat <- as.data.frame(posthocRoot$`pairwise differences of Treatment`)
signRootTreat <- signRootTreat[which(signRootTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signRootTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

Table \@ref(tab:emmeansRoot) allows ranking treatments as follows (from best to worst):

- `IBA_1`: a
- `IBA_05`: ab
- `NAA_1`: ab
- `NAA_05`: b
- `Control`: c

#### Boxplot of rooting by treatment

To support further visual comparison of rooting by treatment, a boxplot was inferred based on the merged dataset (`MERGE`). Figure \@ref(fig:boxplot1) supports ranking from the statistical analysis (Table \@ref(tab:emmeansRoot) and would suggest that `IBA_1` is the most efficient treatment to initiate rooting in sagebrush with a median value of 1 root per tip (whereas other treatments have their median at 0).

```{r boxplot1, echo=T, eval=T, fig.cap="Boxplot comparing number of roots per shoot tip of diploid Artemisia tridentata subsp. tridentata sorted by treatment. Rankings are based on the pairwise least-square means analysis.", out.width="100%"}
###~~~
#Boxplot comparing rooting per treatment
###~~~

# Draw boxplot
boxplot(MERGE$Root ~ MERGE$Treatment, xlab = "Treatment", ylab = "Number of roots per shoot tip", ylim=c(0,12.5), names = c("Control", "IBA 0.5 mg/l", "IBA 1 mg/l", "NAA 0.5 mg/l", "NAA 1 mg/l"))

# Add ranking based on Tukey tests
text(x=c(1,2,3,4,5), y=rep(12.5,5), c("c","ab","a",'ab','ab'))
```

### Investigate individual effect

Here, we are applying a statistical approach to the rooting data to identify individuals which are significantly outperforming the other individuals. To qualify as a top performer, an individual has to outperform >=20% of individuals based on a *p*-value <= 0.01.

Treatment analyses have shown that the zero-inflated negative binomial GLM best fit the data, but we hypothesize that the small individual sample size (n= 15 replicates per individual) could not meet the requirement of this method. Below, we are running this model on individual data (`Root ~ Individual`), but the algorithm is unable to fit the model. 

```{r zeroinflInd, echo=T, eval=T, message=FALSE, warning=FALSE}
# Zero-Inflated Negative Binomial GLM
M1 <- zeroinfl(Root ~ IndGeno, dist = 'negbin', data = MERGE) 

# Summary of M1
summary(M1)
```

In this context, we are investigating individual effect on rooting by applying a non-parametric Kruskal-Wallis rank sum test followed by a pairwise Wilcoxon rank sum tests to identify individual top performers.

```{r kruskalInd, echo=T, eval=T, message=FALSE, warning=FALSE}
# Run Kruskal-Wallis Rank Sum Test
K1 <- kruskal.test(Root ~ IndGeno, data = MERGE)
print(K1)

# Run Wilcox test on Root ~ IndGeno
wilcoxRootInd <- pairwise.wilcox.test(MERGE$Root, MERGE$IndGeno,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootInd <- wilcoxRootInd$p.value

# Convert distance matrix into 3 cols: ind1, ind2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootInd)){
  tmp <- wilcoxRootInd[i,]
  tmp <- cbind(rep(rownames(wilcoxRootInd)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Ind1", "Ind2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Individual effect
IndRoot <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per individual
meanRoot <- aggregate(Root ~ IndGeno, mean, data = MERGE)

# Diff of means Ind1-Ind2
IndRoot$Diff_mean <- meanRoot[match(IndRoot[,1], meanRoot[,1]),2]-meanRoot[match(IndRoot[,2], meanRoot[,1]),2]

# What are the top performers (= most efficient at producing roots)?
IndRootOut <- IndRoot[which(IndRoot$Diff_mean > 0),]

# Percentage of individuals that are outperformed by P1
TopInd <- 100*(sort(table(IndRootOut[,1]), decreasing=T)/length(unique(MERGE$IndGeno)))

# Select only ind that are outperforming at least 20% of individuals 
TopInd <- TopInd[which(TopInd >= 20)]

TopInd <- as.matrix(round(TopInd, 1))
colnames(TopInd) <- c("Percentage of individuals outperformed")

# Plot table
knitr::kable(TopInd, caption = "List of individual that are outperforming at least 20% of individuals (based on Wilcoxon rank sum tests on Individual variable with a pval <= 0.01).")
```

The analyses reported in Table \@ref(tab:kruskalInd) demonstrate that only two individuals (`r rownames(TopInd)`, which are referred to as P1 and P2) are significantly outperforming at least 20% of the individuals based on their rooting abilities independently to treatment.


## Clustering analysis of number of roots per shoot tip

A clustering analysis was used to compare rooting performance between individuals of Basin Big sagebrush based on an euclidean distance (using `Root` variable). This analysis sorted individuals into rooting clusters based on their abilities to initiate rooting (which is also shown by the heatmap). Finally, to performer individuals (P1 and P2) identified by the statistical analyses are also represented on the graph. The code used to produce these analyses is available below. The analysis clearly distinguished three clusters (of even number of individuals; see Table \@ref(tab:tablegroups)) based on individual rooting performances (Figure \@ref(fig:heatmap2)):

- Black cluster: No to very little rooting.
- Pink cluster: Some rooting observed.
- Blue cluster: Most individuals are exhibiting high rooting capacity and the top three performers belong to this cluster.

### Code to produce clustering analysis on rooting data

```{r heatmap1, echo=T, eval=F}
###~~
#Clustering analysis on rooting data
###~~~
# Create our own color palette from green to red for heatmap
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = 299)

# Input data for clustering and heatmap
mat_data <- table(MERGE$IndGeno, MERGE$Root)

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Annotate best perfoming individuals and add P1, P2
toAdd <- which(rownames(mat_data) %in% rownames(TopInd))
rownames(mat_data)[toAdd] <- paste0(rownames(mat_data)[toAdd], c(" (P1)", " (P2)"))

pdf("03_Figures_report/Fig_2_Heatmap_compare_ind_rooting.pdf")
# Perform clustering/heatmap and draw plot
heatmap.2(mat_data,
          cellnote = mat_data, # same data set for cell labels
          main = "", # heat map title
          notecol="black",      # change font color of cell labels to black
          notecex = .8, # cex of numbers in cells
          density.info="none",  # turns off density plot inside color legend
          trace="none",         # turns off trace lines inside the heat map
          xlab = 'N. roots per tip (1 ind. has 15 tips)', #Label of x axis
          cexRow = .8, # cex of rows (= samples ID)
          margins =c(4,9),     # widens margins around plot
          col=my_palette,       # use on color palette defined earlier
          #breaks=col_breaks,    # enable color transition at specified limits
          dendrogram="row", # only draw a row dendrogram
          key=F,
          keysize = 0.4,
          RowSideColors = as.vector(colInd$Group),
          Colv="NA") # turn off column clustering
dev.off()
```

```{r heatmap2, echo=F, eval=T, fig.cap="Heatmap comparing calli production of shoot tips of diploid Artemisia tridentata subsp. tridentata showing three clusters, which are not identical to those inferred with rooting data. The position of top performers as identified by the Tukey tests on rooting data is also displayed.", out.width="100%"}
knitr::include_graphics("03_Figures_report/Fig_2_Heatmap_compare_ind_rooting.png")
```

### Code to produce Table \@ref(tab:tablegroups)

The number of individual per rooting clusters inferred from the clustering analysis is displayed in Table \@ref(tab:tablegroups). The code to generate this table is found below.

```{r tablegroups, echo=T, eval=T}
###~~~
#Produce pivot table with number of individual per group and genotype composition
###~~~
# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# colInd add Genotypes
colInd$Genotype <- sapply(strsplit(as.vector(colInd$Individual), split="_"), "[[", 1)
tabGroup <- table(colInd$Group, colInd$Genotype)
tabGroup <- tabGroup[c(1,3,2),]
tabGroup <- as.data.frame.matrix(tabGroup)
tabGroup$TOT <- rowSums(tabGroup)

# Plot table
knitr::kable(tabGroup, row.names=T, caption = "Table summarizing composition of clusters based on rooting data.")
```

### Effect of growth regulators on *in vitro* rooting sorted by clusters

Table \@ref(tab:growthbyregulatorcluster) shows that IBA at both concentrations seem to have a significant effect on rooting for individuals belonging to the blue cluster (Figure \@ref(fig:heatmap2)). Responses are very high (both at 87.18%) and the number of roots per tip are 2.97 +/- 2.25 for IBA 0.5 and 3.59 +/- 3.41 for IBA 1 (Table \@ref(tab:growthbyregulatorcluster)).

```{r growthbyregulatorcluster, echo=T, eval=T}
#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
treat <- sort(unique(MERGE$Treatment))

#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatC <- matrix(ncol=6, nrow=15)
colnames(RootingStatbyTreatC) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots", "Treatment")

#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

#Convert to dataframe
RootingStatbyTreatC <- as.data.frame(RootingStatbyTreatC)

#Populate matrix
RootingStatbyTreatC$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatC$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatC$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatC$Treatment <- rep(treat, 3)

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreatC)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatC$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatC$Cluster[i])
  RootingStatbyTreatC$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep= " ")
  RootingStatbyTreatC$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreatC[,1:5], row.names=F, caption = "Effect of growth regulator on in vitro rooting of Artemisia tridentata sorted by cluster. Response: mean of the three replicates +/- standard deviation; Av. No. of roots: mean +/- standard deviation.")
```

This will be investigated by looking at top performer individuals identified by i) ANOVA analyses and ii) clustering analysis.


## Statistical analyses on callus data 

Table \@ref(tab:growthbyregulatorcallus) demonstrated that >70% of shoot tips undergoing growth regulator treatments developed calli, whereas those in the control treatment had very limited calli development (< 3%). This preliminary result strongly suggested that calli were induced by growth regulators and we will be testing this hypothesis using statistical analyses.

### Test for normality

Before conducting statistical analyses, we have to test for normality of callus data using the Shapiro-Wilk normality test implemented in the R base function `shapiro.test()`. A *p*-value <= 0.01 is will be used for significance.

```{r normalitytestcallus, eval=T, echo=T}
#Conducting Shapiro-Wilk normality test on root data
Callusnorm <- shapiro.test(MERGE$Callus)
print(Callusnorm)
```

The test strongly rejects normality of the rooting data. In this context, we aim at analyzing the data using general linear models (`glm`), but what is the best fitted family/model to describe the data distribution? Let's look at the distribution of the data (Figure \@ref(fig:distrCall)):

```{r distrCall, echo=T, eval=T, fig.cap="Barplot of callus production during the rooting experiment."}
barplot(table(MERGE$Callus), xlab="Binary data on callus", ylab="Occurrence")
```

The bi-modal nature of the data (Figure \@ref(fig:distrCall)) calls for the use of the binomial family in the `glm` analyses.

### Investigate treatment and individual effects 

We start by comparing `glm` models  investigating the effect of treatment and individual on callus production.

```{r}
# GLM to investigate treatment effect on callus production
M1cal <- glm(Callus ~ Treatment, family = binomial(link="logit"), data = MERGE)

# GLM to investigate treatment and individual effects on callus production
M2cal <- glm(Callus ~ Treatment + IndGeno, family = binomial(link="logit"), data = MERGE)

# Which model best fit the data?
anova(M1cal, M2cal, test = "Chisq")

# M2 better fits the data, but is it not over fitting it?
pchisq(M2cal$deviance, M2cal$df.residual, lower.tail = F)

# Summary M2
print(summary(M2cal))
```

The analyses demonstrate that there is significant treatment and individual effects.

### Ranking treatments

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansCal, eval=T, echo=T}
# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallus <- emmeans(M2cal, list(pairwise ~ Treatment))

# Identify significant pairwise comparisons
signCalTreat <- as.data.frame(posthocCallus$`pairwise differences of Treatment`)
signCalTreat <- signCalTreat[which(signCalTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

Table \@ref(tab:emmeansCal) summarizes statistical comparison of treatments focusing on significant effects. These analyses are not entirely conclusive, but they demonstrate that:

- (a) Control is significantly different than the other treatments (`***`). Here, very limited calli production was observed in shoot tips included in the control treatment.
- (b) No significant differences between IBA_1, IBA_05, NAA_01 and NAA_05.

#### Investigate individual effect

We are using the same approach as with the treatment to perform pairwise comparisons to identify individuals that are significantly producing calli independently of treatment. The tests concluded that although the `glm` supported some individual effect, none of the individuals are significantly different based on the post hoc tests.

```{r emmeansCalInd, eval=T, echo=T}
# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallusInd <- emmeans(M2cal, list(pairwise ~ IndGeno))

# Identify significant pairwise comparisons
signCalTreatInd <- as.data.frame(posthocCallusInd$`pairwise differences of IndGeno`)
signCalTreatInd <- signCalTreatInd[which(signCalTreatInd$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreatInd, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

### Clustering analysis of calli data

The code to produce the clustering analysis based on `Callus` data and associated heatmap is provided below and Figure \@ref(fig:heatmapplot) shows results of the analysis. Outcomes of this analysis are:

- Three clusters based on calli production:
  + Bottom cluster has individuals with no to very limited calli production.
  + Intermediate cluster has individuals with 50/50 calli production.
  + Top cluster has individuals with individuals producing calli.
- Clusters from the rooting analysis are not recovered here (each calli cluster are composed by a mixture of clusters from the rooting analysis). This suggests that calli production do not inhibit rooting.
- To performer individuals are shared between the intermediate and top clusters (supporting previous statement).

```{r heatmapcode, echo=T, eval=F}
###~~~
#Clustering analysis on calli data
###~~~

# Create our own color palette from green to red for heatmap
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = 299)

#Input data for heatmap
mat_data <- table(MERGE$IndGeno, MERGE$Callus)

#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

#Annotate best perfoming individuals (based on Tukey test) and add P1, P2
toAdd <- which(rownames(mat_data) %in% rownames(TopInd))
rownames(mat_data)[toAdd] <- paste0(rownames(mat_data)[toAdd], c(" (P1)", " (P2)"))

pdf("03_Figures_report/Fig_3_Heatmap_compare_ind_callus.pdf")
#Draw plot
heatmap.2(mat_data,
                 cellnote = mat_data, # same data set for cell labels
                 main = "", # heat map title
                 notecol="black",      # change font color of cell labels to black
                 notecex = .8, # cex of numbers in cells
                 density.info="none",  # turns off density plot inside color legend
                 trace="none",         # turns off trace lines inside the heat map
                 xlab = 'Presence (1) / absence (0) of callus in tip', #Label of x axis
                 cexRow = .8,
          cexCol = .9,# cex of rows (= samples ID)
                 margins =c(4,9),     # widens margins around plot
                 col=my_palette,       # use on color palette defined earlier
                 #breaks=col_breaks,    # enable color transition at specified limits
                 dendrogram="row", # only draw a row dendrogram
                 key=F,
                 keysize = 0.4,
                 RowSideColors = as.vector(colInd$Group),
                 Colv="NA")
dev.off()
```
```{r heatmapplot, echo=F, eval=T, fig.cap="Heatmap comparing calli production of sagebrush individuals showing three clusters, which are not identical to those inferred with rooting data. The position of top performers as identifed by the Tukey tests is also displayed.", out.width="100%"}
knitr::include_graphics("03_Figures_report/Fig_3_Heatmap_compare_ind_callus.png")
```

### Effect of growth regulators on *in vitro* calli production in *Artemisia tridentata* sorted by rooting clusters

Table \@ref(tab:growthbyregulatorclustercallus) shows that IBA at both concentrations seem to have a significant effect on calli production for individuals belonging to the blue cluster (Figure \@ref(fig:heatmap2)).

```{r growthbyregulatorclustercallus, echo=T, eval=T}
###~~~
#Effect of growth regulators on calli production sorted by rooting cluster
###~~~

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Create vector of treatments
treat <- sort(unique(MERGE$Treatment))

# Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatCal <- matrix(ncol=5, nrow=15)
colnames(RootingStatbyTreatCal) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Treatment")

# Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

# Convert to dataframe
RootingStatbyTreatCal <- as.data.frame(RootingStatbyTreatCal)

# Populate matrix
RootingStatbyTreatCal$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatCal$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatCal$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatCal$Treatment <- rep(treat, 3)

# Infer Response
for(i in 1:nrow(RootingStatbyTreatCal)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatCal$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatCal$Cluster[i])
  RootingStatbyTreatCal$`Response (%)`[i] <- round(100*(mean(foo$Callus)),2)
}

#Plot table
knitr::kable(RootingStatbyTreatCal[,1:5], row.names=F, caption = "Effect of growth regulators on in vitro calli production on shoot tips of diploid Artemisia tridentata subsp. tridentata sorted by rooting clusters. Response: mean of the three replicates.")
```


# Step 4: *In vitro* growth of plantlets

## Sampling and preliminary analysis on survival and plantlets heights

Data on survival and plantlets heights are stored in `01_Raw_Data/Survival_height_clones.csv`. The code below provides statistics on the number of individual and shoot tips included in this experiment. 

```{r statgrowth, echo=T, eval=T}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

###~~~
#How many individuals where transfered corresponding how many shoot tips
###~~~
stats <- matrix(ncol=1, nrow=4)
colnames(stats) <- "Sampling"
rownames(stats) <- c("Total N. ind.", "N. ind. per gen,","Total N. shoot tips", "N. shoot tips per gen.")

#Add N ind and N shoot tips
stats[c(1,3),] <- c(length(unique(survheig$SeedID)), sum(table(survheig$SeedID)))

#Tot ind per genotypes
totindgen <- table(sapply(strsplit(as.vector(unique(survheig$SeedID)), "_"), '[[', 1))
stats[2,1] <- paste0(paste0(names(totindgen), ":"), totindgen, collapse = '/')

#N shoot per genotypes
totgenshoot <- table(sapply(strsplit(as.vector(survheig$SeedID), "_"), '[[', 1))
stats[4,1] <- paste0(paste0(names(totgenshoot), ":"), totgenshoot, collapse = '/')


print(stats)

###~~~
#Breakdown of number of shoot tips per individual
###~~~

#Sort based on number of shoot tips
sort(table(survheig$SeedID), decreasing=T)
```

### Survival and plantlets heights at 3 and 5 weeks

Results of the code provided below is summarized in Table \@ref(tab:surv). After 5 weeks, a survival of 53.48% of the plantlets was observed. A significant increase of plantlets mortality has been recorded between weeks 3 and 5 and on average, plantlets did not growth significant (but see below for more details).   

```{r surv, echo=T, eval=T}
###~~~
# Matrix to store data @ 3 and 5 weeks
###~~~
survheigStat <- matrix(ncol=2, nrow = 2)
colnames(survheigStat) <- c("Survival (%)", "Plant height (cm)")
rownames(survheigStat) <- c("Week 3", "Week 5")

###
#3 weeks
###

# Survivial
ThreeWsurvAll <- table(survheig$X3_w_survival)
survheigStat[1,1] <- round(100*((sum(ThreeWsurvAll)-ThreeWsurvAll[which(names(ThreeWsurvAll) == 0)])/sum(ThreeWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[1,2] <- paste0(round(mean(survheig$X3_w_height),2), "+/-", round(sd(survheig$X3_w_height),2))

###
#5 weeks
###

# Survivial
FiveWsurvAll <- table(survheig$X5_w_survival)
survheigStat[2,1] <- round(100*((sum(FiveWsurvAll)-FiveWsurvAll[which(names(FiveWsurvAll) == 0)])/sum(FiveWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[2,2] <- paste0(round(mean(survheig$X5_w_height),2), "+/-", round(sd(survheig$X5_w_height),2))


# Plot table
knitr::kable(survheigStat, row.names=T, caption = "Survival and plantlets heights at 3 and 5 weeks (+/- standard deviations).")
```

### Survival and plantlets height sorted by rooting clusters

Table \@ref(survclust) shows data on survival, plantlets heights at 3 and 5 weeks sorted by rooting clusters. Data on the number of individuals and shoot tips included in this experiment for each rooting cluster is also provided. 

```{r survclust, echo=T, eval=T}
###
#Create list of clusters
###
clust <- sort(unique(survheig$Cluster))[c(1,3,2)]

###~~~
#Matrix with data on cluster, N. ind, N. shoot tips, survival and height
###~~~
clustSurvHeig <- matrix(ncol=7, nrow = length(clust))
colnames(clustSurvHeig) <- c("Rooting cluster", "N. ind.","N. shoot tips", "3 w. surv. (%)", "3 w. plant height (cm)", "5 w. surv. (%)", "5 w. plant height (cm)")
clustSurvHeig[,1] <- as.character(clust)

for(i in 1:length(clust)){
  #Subset mat to clust
  tmp <- subset(survheig, survheig$Cluster == clust[i])
  
  ###
  #3 weeks
  ###
  #N. ind.
  clustSurvHeig[i,2] <- length(unique(tmp$SeedID))
  #N. shoot tips
  clustSurvHeig[i,3] <- nrow(tmp)
  #Survivial
  ThreeWsurv <- table(tmp$X3_w_survival)
  clustSurvHeig[i,4] <- round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,5] <- paste0(round(mean(tmp$X3_w_height),2), "+/-", round(sd(tmp$X3_w_height),2))
  
  ###
  #5 weeks
  ###
  #Survivial
  FiveWsurv <- table(tmp$X5_w_survival)
  clustSurvHeig[i,6] <- round(100*((sum(FiveWsurv)-FiveWsurv[which(names(FiveWsurv) == 0)])/sum(FiveWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,7] <- paste0(round(mean(tmp$X5_w_height),2), "+/-", round(sd(tmp$X5_w_height),2))
}

#Plot table
knitr::kable(clustSurvHeig, row.names=F, caption = "Survival and plantlets heights at 3 and 5 weeks sorted by rooting clusters.")
```

### Survival and plantlets height at 5 weeks sorted by rooting clusters and treatments

Table \@ref(tab:survclusttreat) shows survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.

```{r survclusttreat, echo=T, eval=T}
###~~~
#Split survheig$Treatment to extract growth regulator and concentration
###~~~
survheig$TreatConc <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 2), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 3), sep="_")
survheig$TreatConc[grep("Control_", survheig$TreatConc)] <- "Control"

#Vector of treatments
treat <- sort(unique(survheig$TreatConc))

###~~~
#Matrix summarizing effect of growth regulators on rooting
###~~~
survheigTreat <- matrix(ncol=8, nrow=15)
colnames(survheigTreat) <- c("Cluster", "N. ind.","N. shoot tips","Growth regulator", "Concentration (mg/l)", "Survival (%)", "Height (cm)", "Treatment")

#Convert to dataframe
survheigTreat <- as.data.frame(survheigTreat)

#Populate matrix
survheigTreat$Cluster <- sort(rep(clust,5))
survheigTreat$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
survheigTreat$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
survheigTreat$Treatment <- rep(treat, 3)

#Infer N, surv and plant height
for(i in 1:nrow(survheigTreat)){
  foo <- subset(survheig, survheig$TreatConc == survheigTreat$Treatment[i] & survheig$Cluster == survheigTreat$Cluster[i])
  
  if(nrow(foo) > 0){
    #N. ind.
    survheigTreat$`N. ind.`[i] <- length(unique(foo$SeedID))
    #N. shoot tips
    survheigTreat$`N. shoot tips`[i] <- nrow(foo)
    #Survivial
    ThreeWsurv <- table(foo$X5_w_survival)
    survheigTreat$`Survival (%)`[i] <-   round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
    #Mean plant height +/- sd
    survheigTreat$`Height (cm)`[i] <- paste0(round(mean(foo$X5_w_height),2), "+/-", round(sd(foo$X5_w_height),2))  
  }
  
}

#Save to be included in manuscript
#write.csv(survheigTreat, file='Survival_cluster_treatment_5w.csv')

#Plot table
knitr::kable(survheigTreat, row.names=F, caption = "Survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.")

```

## Statistical analyses

Here, we will use ANOVAs followed by Tukey tests to test whether treatment, individual, rooting cluster or number of roots per shoot tip predicted survival and heights of plantlets after 5-weeks of culture.

### Treatment, individual, cluster effects on plantlet survival

These analyses are done on data in `survheig`, more specifically on `survheig$X5_w_survival` and extracting treatments from `survheig$Treatment` (which contains block, treatment and replicate information in one object).

```{r}
####~~~~
#Infer treatment types recieved by plantles
###~~~
survheig$Treat <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(2)), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(3)), sep="_")
survheig$Treat[grep("Control_", survheig$Treat)] <- "Control"

###~~~
#Turn survival into a binary data (sickly plantlets have a score of 0.5, but will be changed to 1)
###~~~
survheig$X5_w_survival[which(survheig$X5_w_survival == 0.5)] <- 1

###~~~~
#Define ANOVA model and run analysis
###~~~
anovaOUTsurv<- aov(X5_w_survival ~ Treat * SeedID * Cluster, data = survheig)


# Summary of ANOVA
summary(anovaOUTsurv)

# The lack of treatment effect is confirmed by this table showing that there is a 50/50 chance of survival across treatments
table(survheig$X5_w_survival, survheig$Treat)
```

The ANOVA shows that there is no treatment effect on survival, but rather that survival is again predicted by individual effect (*p*-value <= 0.001). When Tukey tests are conducted on individual data and with a *p*-value of 0.01, only one individual (`G2_b8_1`) is exhibiting significantly higher death rates than 2 other individuals. Overall, this results means that at this stage, individuals are all performing equally (with the exception of one which has a very high death rate). 

```{r tukeysurv, echo=T, eval=T}
###~~~
#Tukey tests on significant variables
###~~~

# Vector with significant variables (only one here)
significant_vars <- c("SeedID")

# Run Tukey tests
anovaOUTsurv_tukey <- TukeyHSD(anovaOUTsurv, significant_vars)

# Save analysis
saveRDS(anovaOUTsurv_tukey,"02_Processed_data/rds_tables/TukeySurv.rds")

#Investigate individual effect (***)
IndTukeySurv <- anovaOUTsurv_tukey$SeedID[which(as.numeric(anovaOUTsurv_tukey$SeedID[,4]) <= 0.01),]

## This analysis shows that ind G2_b8_1 has significantly higher death rate than two other individuals
print(IndTukeySurv)
```

### Effect of number of roots, individual or rooting clusters on plantlet heights

Here, we will only work on alive plantlets (`survheig$X5_w_survival` == 1) and conduct an ANOVA followed by Tukey tests as follows:

```{r anovaroot, echo=T, eval=T}
###~~~
#Subset surveigh to include only alive plantlets after 5 weeks
###~~~

#All plantlets surviving after 5 weeks of culture 
subSurvHeigh <- subset(survheig, survheig$X5_w_survival != "0")

###~~~
#Fetch number of roots per shoot tip
###~~~

#Fetch no. roots of shoot tips in subSurvHeigh by querying MERGE
MERGE$BlockTreatRep <- paste(MERGE$Block, MERGE$Treatment, MERGE$Replicate, sep="_")

#Loop to get N roots
subSurvHeigh$Root <- "NULL"
for(i in 1:nrow(subSurvHeigh)){
  tmp <- subset(MERGE, MERGE$IndGeno == subSurvHeigh$SeedID[i] & MERGE$BlockTreatRep == subSurvHeigh$Treatment[i])
  subSurvHeigh$Root[i] <- tmp$Root
}

#subSurvHeigh <- subSurvHeigh[-which(subSurvHeigh$Root == 0),]
###~~~
#Define ANOVA model and run analysis
###~~~
#Since it seemed that treatment had an effect
anovaOUTRoot <- aov(X5_w_height ~ Cluster * SeedID * Root, data = subSurvHeigh)


# Summary of ANOVA
summary(anovaOUTRoot)

```

The Tukey tests show that individuals in the blue rooting cluster are significantly taller than those in the pink cluster (black is not shown different than blue, but it could be due to small sampling size of this cluster). Finally, `G2_b27_1` is significantly taller than 13.88% of the individuals included in this experiment. This individual was identified as a top 3 performer!  

```{r tukeyheight, echo=T, eval=T}
###~~~
#Tukey tests on significant variables
###~~~
# Vector with significant variables (only one here)
significant_vars <- c("SeedID", "Cluster")

# Run Tukey tests
anovaOUTheight_tukey <- TukeyHSD(anovaOUTRoot, significant_vars)

# Save analysis
saveRDS(anovaOUTheight_tukey,"02_Processed_data/rds_tables/TukeyHeight.rds")

###~~~
#Investigate cluster effect (**)
###~~~
ClustTukeyHeight <- anovaOUTheight_tukey$Cluster[which(as.numeric(anovaOUTheight_tukey$Cluster[,4]) <= 0.01),]

# What are the top cluster(s) (= most efficient at growing fast)?
#ClusterTukeyHeightTop <- ClustTukeyHeight[which(ClustTukeyHeight[,1] > 0),]

print(anovaOUTheight_tukey$Cluster)
print("Blue is significantly outperforming pink!")

###~~~
#Investigate individual effect (***)
###~~~
IndTukeyHeight <- anovaOUTheight_tukey$SeedID[which(as.numeric(anovaOUTheight_tukey$SeedID[,4]) <= 0.01),]

# What are the top performers (= most efficient at growing fast)?
IndTukeyHeightTop <- IndTukeyHeight[which(IndTukeyHeight[,1] > 0),]

# Extract best performing ind (first in rownames of comparison)
P1growth <- sapply(strsplit(rownames(IndTukeyHeightTop), split='-'), "[[",1)

# Percentage of individuals that are outperformed by P1
TopIndgrowth <- 100*(sort(table(P1growth), decreasing=T)/length(unique(subSurvHeigh$SeedID)))

## This analysis shows that G2_b27_1 grows significantly faster than 14.28% of the individuals in this experiment
print(TopIndgrowth)
```


## Boxplot of plantlet heights for individuals in blue rooting cluster

Figure \@ref(fig:boxplotheightblue) shows the distribution of plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid *Artemisia tridentata* subsp. *tridentata*. As predicted by the statistical analyses on plantlet heights, `G2_b7_1` among the top three individuals with the fastest growth in our experiment (with `G2_b7_1` being the fastest grower). The top three individuals identified by the rooting analysis are also shown on the boxplot.

```{r boxplotheightblue, echo=T, eval=T, fig.cap="Boxplot showing plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid Artemisia tridentata subsp. tridentata. The n indicates the number of plantlets cultured for each individual. The top three performers as identified by the rooting experiment are also displayed (P1 to P3)."}
###~~~
#Subset to only include from blue rooting cluster
###~~~
blueHeight <- subset(subSurvHeigh, subSurvHeigh$Cluster == 'blue')

#Individual
seedID <- table(as.vector(blueHeight$SeedID))

# Create a vector named "new_order" containing the desired order to display individuals (smaller to taller)
new_order <- with(blueHeight, reorder(as.vector(blueHeight$SeedID), as.numeric(blueHeight$X5_w_height), median , na.rm=T))

# Draw boxplot
boxplot(as.numeric(blueHeight$X5_w_height) ~ new_order, names = paste(names(seedID), paste0("(n: ", as.vector(seedID), ")"), sep = "\n"), las=2, xlab = "", ylab = "Plantlet height (cm)", cex = .8)

#Add P1, P2, P3
top <- which(names(seedID) %in% c("G2_b27_1", "G2_b24_1", "G2_b4_1"))
text(x=top, y=1.8, c("P2", "P1", "P3"))

```

<div id="refs"></div>

# Appendix 1 {.appendix}

Citations of all R packages used to generate this report. 

```{r generateBibliography, results="asis", echo=FALSE, warning = FALSE, message=FALSE}
library("knitcitations")
cleanbib()
options("citation_format" = "pandoc")
read.bibtex(file = "packages.bib")
``` 

# Appendix 2 {.appendix}

Version information about R, the operating system (OS) and attached or R loaded packages. This appendix was generated using `sessionInfo()`.

```{r eval=T, echo=F, warning = FALSE, message=FALSE}
sessionInfo()
```

# Appendix 3 {.appendix}

Sampling at the basis of analyses presented in this study.

```{r tidy, echo=F}
knitr::kable(MERGE, caption = "Sampling at the basis of the sagebrush rooting experiment.")
```
