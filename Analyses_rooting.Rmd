--- 
title: 'Development of an *in vitro* method of propagation using growth regulators for Basin Big sagebrush (*Artemisia tridentata* subsp. *tridentata*) to support genome sequencing and GxE research'
author: "Rachael Barron, Peggy Martinez, Marcelo Serpe, Sven Buerki"
output:
  bookdown::html_document2: 
    toc: TRUE
    toc_float: TRUE
link-citations: yes
fontsize: 12pt
bibliography: packages.bib
---

```{r packages, echo=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(rmarkdown)
library(bookdown)
#library(distill)
library(knitcitations)
library(formatR)
library(devtools)
library(gplots)
library(RColorBrewer)
library(grDevices)
library(pscl)
library(lmtest)
library(lsmeans)
library(emmeans)
library(DT)
library(chisq.posthoc.test)
library(ggpubr)

#Generate BibTex citation file for all R packages used to produce report
knitr::write_bib(.packages(), file = 'packages.bib')
```


```{r setup, include=FALSE, cache=FALSE, message = FALSE}
#Load packages
library(knitr)
library(rmarkdown)
# Chunk options: see http://yihui.name/knitr/options/ ###

## Text results
opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE, include = TRUE)

## Code decoration
#opts_chunk$set(tidy = TRUE, R.options = list(width = 60), highlight = TRUE)

## Caching code
opts_chunk$set(cache = 2, cache.path = "cache/")

## Plots
#opts_chunk$set(fig.path = "Figures_MS/", dev=c('pdf', 'png'), dpi = 300)

## Locate figures as close as possible to requested position (=code)
#opts_chunk$set(fig.pos = "H")
```

# Reproducible workflow

## Integrating code, data, methods and key outcomes

This document is associated to Barron et al. and provides the reproducible workflow integrating data, code, methods and results associated to this study. 

Citations of `R` packages required to conduct this research and produce this document are provided in [Appendix 1]. Version information about `R`, the operating system (OS) and attached or `R` loaded packages are available in [Appendix 2]. The data underpinning this study are deposited on [GitHub](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop). Appendices together with the data and R code presented in this document should allow reproducibility of this study.

# Overview of methodology 

In this document, we are presenting the code associated to the analyses performed on tissue culture data (rooting and calli) generated from shoot tips of diploid *Artemisia tridentata* subsp. *tridentata* (2n=2x=18). 

The analyses were conducted in four steps:

- **Step 1:** Present, import and tidy data (see section \@ref(step1)).
- **Step 2:** Preliminary analyses on rooting experiment (see section \@ref(step2)).
- **Step 3:** Comparative analyses on rooting data (see section \@ref(step3)). This was done following a two-tier approach:
  + Statistical analyses (test for normality and conduct parametric or non-parametric statistics and multiple pairwise-comparison tests with *p*-value <= 0.01).
  + Clustering analyses.
- **Step 4:** *In vitro* survival and growth of plantules (see section \@ref(step4)). 
  + Assessing the effect of growth regulators and rooting clusters on plantule survival and growth rates.

# Step 1: Present, import and tidy data {#step1}

## Data presentation

The raw data used for this study are available in the [Sagebrush_rooting_in_vitro_prop](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop/tree/master/01_Raw_Data) GitHub repository in the `01_Raw_Data` folder. The data can be split into two categories supporting analyses presented in this study:

1. Tissue culture data: These data are related to the rooting experiment conducted on shoot tips.
2. *In vitro* survival and growth of plantules: These data are related to the survival and growth experiment of rooted shoot tips into growth media.

We are providing more information on these data below.

### Tissue culture data {.tabset .tabset-pills}

#### Import and tidy data

The objective of this section is to merge data on rooting and callus stored in spreadsheets (in `csv` format). Each spreadsheet corresponds to a block and the code provided in section \@ref(tidy) collates these data into one `data.frame` for downstream analyses. 

```{r tidy1, echo=FALSE, eval=TRUE}
###~~
#List all csv files (raw data from blocks)
###~~~

#Raw data are stored in the 01_Raw_Data folder
csv <- list.files(path = "01_Raw_Data", pattern='block.csv', full.names = T)

#Print names of csv files
print("List of csv files with block data:")
print(csv)

#Rm processed files
toRm <- grep("Processed_", csv)
if(length(toRm) > 0){
  csv <- csv[-toRm]
}

###~~~
#Execute loop to process all files and merge them (see below)
###~~~
# Empty object that will contain all processed data
# Save processed data into 02_Processed_data folder
MERGE <- NULL
for(i in 1:length(csv)){
  ###
  #Read in sv file
  mat <- read.csv(csv[i])
  
  ###~~~
  #Create final matrix
  ###~~~
  
  #List of individuals
  indcsv <- LETTERS[seq( from = 1, to = 9 )]
  
  #Empty matrix
  FINALmat <- data.frame(matrix(ncol=7, nrow = nrow(mat)*length(indcsv)))
  colnames(FINALmat) <- c("Block","Treatment", "Replicate", "Genotype", "Individual", "Callus", "Root")
  
  ###~~~
  #Start populating FINALmat 
  ###~~~
  # Add Block, Treatment and Replicates
  #Get data for block, treatment (and replicates)
  blockTreatRep <- rep(as.vector(mat$X), 9)
  FINALmat$Block <- sapply(strsplit(blockTreatRep, split='_'), "[", 1)
  FINALmat$Treatment <- paste(sapply(strsplit(blockTreatRep, split='_'), "[", 2), sapply(strsplit(blockTreatRep, split='_'), "[", 3), sep='_')
  FINALmat$Replicate <- sapply(strsplit(blockTreatRep, split='_'), "[", 4)
  
  #Deal with Controls
  contr <- grep("Control_", FINALmat$Treatment)
  FINALmat$Replicate[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",2)
  FINALmat$Treatment[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",1)
  
  ###~~~
  # Fetch individual data
  ###~~~
  
  #Where are ind in mat?
  indcol <- match(indcsv, colnames(mat))
  
  #Fetch raw data for each individual in block
  OUT <- NULL
  for(j in 1:length(indcol)){
    #Extract info for each individual
    tmp <- mat[,indcol[j]:(indcol[j]+2)]
    colnames(tmp) <- c("Ind", "Callus", "Root")
    OUT <- rbind(OUT, tmp)
  }
  
  ###~~~
  #Add OUT to FINALmat
  ###~~~
  
  #Genotypes
  FINALmat$Genotype <- sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 1)
  #Ind
  FINALmat$Individual <- paste(sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 2), sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 3), sep='_')
  #Callus
  FINALmat$Callus <- OUT$Callus
  #Root
  FINALmat$Root <- OUT$Root
  
  ###~~~
  #Save FINALmat
  ###~~~
  write.csv(FINALmat, file=paste0("02_Processed_data/Processed_", strsplit(csv[i], split="/")[[1]][2]), row.names = F, quote = F)
  
  ###~~~
  #MERGE all csv
  ###~~~
  MERGE <- rbind(MERGE, FINALmat)
}

###~~~
#Finalize preping of the data
###~~~
# Add a binary rooting col
MERGE <- data.frame(MERGE)

MERGE$IndGeno <- paste(MERGE$Genotype, MERGE$Individual, sep="_")

#Create a binary for Root
MERGE$RootBin <- MERGE$Root
MERGE$RootBin[MERGE$RootBin > 0] <- 1

###~~~
#Save MERGED files with all blocks
###~~~
# Save processed data into 02_Processed_data folder
write.csv(MERGE, file=paste0("02_Processed_data/Processed_", "blocks_rooting.csv"), row.names = F, quote = F)

#Return head of MERGE (see Appendix for more details)
print("Merge files and print head of data.frame:")
head(MERGE[,1:ncol(MERGE[-1])])
```

The final dataset (`MERGE`) contains the following columns (see Table \@ref(tab:statssampling) for more details on sampling):

- `Block`: 1 to 5. Each individual were randomly allocated to a block and a block has 9 individual.
- `Treatment`: `Control` (= no growth regulator), `IBA_1` (IBA 1 mg/l), `IBA_05` (IBA 0.5 mg/l), `NAA_1` (NAA 1 mg/l), `NAA_05` (NAA 0.5 mg/l).
- `Replicate`: 1 to 3. Each individual had 3 shoot tips randomly allocated per treatment.
- `Genotype`: `G1` (drought-tolerant genotype from ID3 population) and `G2` (drought-sensitive population from UT2 population). See distribution [map](https://svenbuerki.github.io/Sagebrush_rooting_in_vitro_prop/location_pop.html).
- Individual: `Individual` and `IndGeno`. The latter variable combines data on genotype and individual and it will be used throughout the document to represent the individual variable.
- `Callus`: Binary (1 = present; 0 = absent).
- `Root`: Count of number of roots per shoot tip.

The `MERGE` dataset is available in [Appendix 3] and can be directly there. The individual and merged processed files are available in the `02_Processed_data` folder (see file `Processed_blocks_rooting.csv` for merged data or click [here](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop/blob/master/02_Processed_data/Processed_blocks_rooting.csv)).

#### R code {#tidy}

Raw data in `csv` format are stored in the `01_Raw_data` folder. The processed/tidy data are saved in `csv` format in the `02_Processed_data` folder. The `MERGE` object (in class `data.frame`) will be used for downstream analyses.

```{r tidy12, echo=T, eval=F}
###~~
#List all csv files (raw data from blocks)
###~~~

#Raw data are stored in the 01_Raw_Data folder
csv <- list.files(path = "01_Raw_Data", pattern='block.csv', full.names = T)

#Print names of csv files
print(csv)

#Rm processed files
toRm <- grep("Processed_", csv)
if(length(toRm) > 0){
  csv <- csv[-toRm]
}

###~~~
#Execute loop to process all files and merge them (see below)
###~~~
# Empty object that will contain all processed data
# Save processed data into 02_Processed_data folder
MERGE <- NULL
for(i in 1:length(csv)){
  ###
  #Read in sv file
  mat <- read.csv(csv[i])
  
  ###~~~
  #Create final matrix
  ###~~~
  
  #List of individuals
  indcsv <- LETTERS[seq( from = 1, to = 9 )]
  
  #Empty matrix
  FINALmat <- data.frame(matrix(ncol=7, nrow = nrow(mat)*length(indcsv)))
  colnames(FINALmat) <- c("Block","Treatment", "Replicate", "Genotype", "Individual", "Callus", "Root")
  
  ###~~~
  #Start populating FINALmat 
  ###~~~
  # Add Block, Treatment and Replicates
  #Get data for block, treatment (and replicates)
  blockTreatRep <- rep(as.vector(mat$X), 9)
  FINALmat$Block <- sapply(strsplit(blockTreatRep, split='_'), "[", 1)
  FINALmat$Treatment <- paste(sapply(strsplit(blockTreatRep, split='_'), "[", 2), sapply(strsplit(blockTreatRep, split='_'), "[", 3), sep='_')
  FINALmat$Replicate <- sapply(strsplit(blockTreatRep, split='_'), "[", 4)
  
  #Deal with Controls
  contr <- grep("Control_", FINALmat$Treatment)
  FINALmat$Replicate[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",2)
  FINALmat$Treatment[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",1)
  
  ###~~~
  # Fetch individual data
  ###~~~
  
  #Where are ind in mat?
  indcol <- match(indcsv, colnames(mat))
  
  #Fetch raw data for each individual in block
  OUT <- NULL
  for(j in 1:length(indcol)){
    #Extract info for each individual
    tmp <- mat[,indcol[j]:(indcol[j]+2)]
    colnames(tmp) <- c("Ind", "Callus", "Root")
    OUT <- rbind(OUT, tmp)
  }
  
  ###~~~
  #Add OUT to FINALmat
  ###~~~
  
  #Genotypes
  FINALmat$Genotype <- sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 1)
  #Ind
  FINALmat$Individual <- paste(sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 2), sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 3), sep='_')
  #Callus
  FINALmat$Callus <- OUT$Callus
  #Root
  FINALmat$Root <- OUT$Root
  
  ###~~~
  #Save FINALmat
  ###~~~
  write.csv(FINALmat, file=paste0("02_Processed_data/Processed_", strsplit(csv[i], split="/")[[1]][2]), row.names = F, quote = F)
  
  ###~~~
  #MERGE all csv
  ###~~~
  MERGE <- rbind(MERGE, FINALmat)
}

###~~~
#Finalize preping of the data
###~~~
# Add a binary rooting col
MERGE <- data.frame(MERGE)

MERGE$IndGeno <- paste(MERGE$Genotype, MERGE$Individual, sep="_")

#Create a binary for Root
MERGE$RootBin <- MERGE$Root
MERGE$RootBin[MERGE$RootBin > 0] <- 1

###~~~
#Save MERGED files with all blocks
###~~~
# Save processed data into 02_Processed_data folder
write.csv(MERGE, file=paste0("02_Processed_data/Processed_", "blocks_rooting.csv"), row.names = F, quote = F)

#Return head of MERGE (see Appendix for more details)
head(MERGE)
```

### *In vitro* survival and growth of plantules {.tabset .tabset-pills}

Data on survival and plantlets heights at 3 and 5 weeks are stored in the `01_Raw_Data` folder in `Survival_height_clones.csv`. The dataset is available in [Appendix 4] and can be directly downloaded there. Please find below the description of the variables:

- `SeedID`: This is equal to `IndGeno` in `MERGE` and therefore refers to the rooted shoot tip that was transferred.
- `Cluster`: Rooting cluster as inferred by the clustering analysis.
- `X3_w_survival` and `X5_w_survival`: Binary survival (1 = alive, 0 = dead) data at 3 and 5 weeks.
- `X3_w_height` and `X5_w_height`: Continuous plantlets heights data (in cm) at 3 and 5 weeks.

# Step 2: Preliminary analyses on rooting experiment {#step2}

Preliminary data summarizing results of our experiments are provided here to assess the effect of growth regulators on *in vitro* rooting of *Artemisia tridentata*. During the course of the experiment, calli developed on a large proportion of shoot tips, which was unexpected based on preliminary data. We are therefore summarizing these data here by treatment and will devote a portion of the analyses to investigate whether callus development was associated to treatments and whether those inhibited or promoted rooting.

## Statistics on plant materials {.tabset .tabset-pills}

### Analyses

Table \@ref(tab:statssampling) provides a summary of plant materials included in this study. Overall, 45 individuals distributed into two genotypes (which were evenly sampled) were generated from seeds. For each individual, 15 shoot tips were produced and included into five treatments with three replicates (= 3 shoot tips/ind./treatment). Individuals were randomly allocated to 5 blocks containing 9 individual each. The code below generates Table \@ref(tab:statssampling). The R code associated to producing Table \@ref(tab:statssampling) is available in section \@ref(statsampl). 

```{r statssampling, echo=FALSE, eval=TRUE}
#Create and populate table to summarize sampling (Table 1)
samp_mat <- matrix(ncol=9, nrow=1)
colnames(samp_mat) <- c("N. block", "N. treatments", "Treatments", "N. replicates", "N. genotypes", 
                        "N. individuals", "N. ind. per genotype", "Ind. G1", "Ind. G2")

#N block
samp_mat[,1] <- length(unique(MERGE$Block))
#N treat
samp_mat[,2] <- length(unique(MERGE$Treatment))
#Treat ID
samp_mat[,3] <- paste(sort(unique(MERGE$Treatment)), collapse = ", ")
#N replicates
samp_mat[,4] <- length(unique(MERGE$Replicate))
#N genotypes
samp_mat[,5] <- length(unique(MERGE$Genotype))
#N ind
samp_mat[,6] <- length(unique(MERGE$IndGeno))
#N ind per genotype
samp_mat[,7] <- paste(paste("G1:", list(table(MERGE$Genotype)/15)[[1]][1]), paste("G2:", list(table(MERGE$Genotype)/15)[[1]][2]), sep=', ')
#List ind G1
samp_mat[,8] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G1"))), collapse=', ')
#List ind G2
samp_mat[,9] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G2"))), collapse=', ')

#Write table
#write.csv(samp_mat, file="Table_1_sampling_summary.csv", row.names = F)

#Plot table
knitr::kable(samp_mat, caption = "Summary of sampling at the basis of sagebrush rooting experiment.")
```

### R code {#statsampl}

```{r statssampling2, echo=TRUE, eval=FALSE}
#Create and populate table to summarize sampling (Table 1)
samp_mat <- matrix(ncol=9, nrow=1)
colnames(samp_mat) <- c("N. block", "N. treatments", "Treatments", "N. replicates", "N. genotypes", 
                        "N. individuals", "N. ind. per genotype", "Ind. G1", "Ind. G2")

#N block
samp_mat[,1] <- length(unique(MERGE$Block))
#N treat
samp_mat[,2] <- length(unique(MERGE$Treatment))
#Treat ID
samp_mat[,3] <- paste(sort(unique(MERGE$Treatment)), collapse = ", ")
#N replicates
samp_mat[,4] <- length(unique(MERGE$Replicate))
#N genotypes
samp_mat[,5] <- length(unique(MERGE$Genotype))
#N ind
samp_mat[,6] <- length(unique(MERGE$IndGeno))
#N ind per genotype
samp_mat[,7] <- paste(paste("G1:", list(table(MERGE$Genotype)/15)[[1]][1]), paste("G2:", list(table(MERGE$Genotype)/15)[[1]][2]), sep=', ')
#List ind G1
samp_mat[,8] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G1"))), collapse=', ')
#List ind G2
samp_mat[,9] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G2"))), collapse=', ')

#Write table
#write.csv(samp_mat, file="Table_1_sampling_summary.csv", row.names = F)

#Plot table
knitr::kable(samp_mat, caption = "Summary of sampling at the basis of sagebrush rooting experiment.")
```


## Effect of growth regulators on *in vitro* callus development in *Artemisia tridentata* {.tabset .tabset-pills}

### Analyses

The effect of growth regulators on callus development is provided in Table \@ref(tab:growthbyregulatorcallus) and compared to the control treatment (= no growth regulator). These data show contrasting calli development between the control and treatments including growth hormones. Control shoot tips had limited calli development, whereas responses for those undergoing treatments were very high (>70%; Table \@ref(tab:growthbyregulatorcallus)). The R code associated to these analyses is presented in section \@ref(growthbyregulatorcallus).

```{r growthbyregulatorcallus, echo=F, eval=T}
#Matrix summarizing effect of growth regulators on rooting
CallusStatbyTreat <- matrix(ncol=3, nrow=5)
colnames(CallusStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)")
rownames(CallusStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
CallusStatbyTreat <- as.data.frame(CallusStatbyTreat)

#Populate matrix
CallusStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(CallusStatbyTreat), split="_"),"[[",1)
CallusStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(CallusStatbyTreat)[2:nrow(CallusStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(CallusStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(CallusStatbyTreat)[i])
  CallusStatbyTreat$`Response (%)`[i] <- paste(round(100*mean(foo$Callus),2), "+/-", round(sd(foo$Callus),2), sep = " ") 
}


#Plot table
knitr::kable(CallusStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro calli development on shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates (+/- standard deviation).")
```

### R code {#growthbyregulatorcallus}

```{r growthbyregulatorcalluscode, echo=T, eval=F}
#Matrix summarizing effect of growth regulators on rooting
CallusStatbyTreat <- matrix(ncol=3, nrow=5)
colnames(CallusStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)")
rownames(CallusStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
CallusStatbyTreat <- as.data.frame(CallusStatbyTreat)

#Populate matrix
CallusStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(CallusStatbyTreat), split="_"),"[[",1)
CallusStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(CallusStatbyTreat)[2:nrow(CallusStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(CallusStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(CallusStatbyTreat)[i])
  CallusStatbyTreat$`Response (%)`[i] <- paste(round(100*mean(foo$Callus),2), "+/-", round(sd(foo$Callus),2), sep = " ") 
}


#Plot table
knitr::kable(CallusStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro calli development on shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates (+/- standard deviation).")
```

## Effect of growth regulators on *in vitro* rooting of *Artemisia tridentata* {.tabset .tabset-pills}

### Analyses

The effect of growth regulators is provided in Table \@ref(tab:growthbyregulator) and compared to the control treatment (= no growth regulator). These data show a very high level of variation in rooting (see column `Av. No. roots`). We are hypothesizing that this trend is caused by an individual effect. To test this hypothesis we will conduct comparative analyses (see **Step 4**) to sort individuals based on their rooting abilities. Finally, the effect of growth regulators on *in vitro* rooting will be compared within each cluster. The R code associated to these analyses is presented in section \@ref(growthbyregulatorcode).

```{r growthbyregulator, echo=F, eval=T}
#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreat <- matrix(ncol=4, nrow=5)
colnames(RootingStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots")
rownames(RootingStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
RootingStatbyTreat <- as.data.frame(RootingStatbyTreat)

#Populate matrix
RootingStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(RootingStatbyTreat), split="_"),"[[",1)
RootingStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(RootingStatbyTreat)[2:nrow(RootingStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(RootingStatbyTreat)[i])
  RootingStatbyTreat$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep=" ")
  RootingStatbyTreat$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro rooting for shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates +/- standard deviation; Av. No. of roots (Average number of roots per shoot tip): mean +/- standard deviation.")
```

### R code {#growthbyregulatorcode}

```{r growthbyregulatorcode, echo=T, eval=F}
#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreat <- matrix(ncol=4, nrow=5)
colnames(RootingStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots")
rownames(RootingStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
RootingStatbyTreat <- as.data.frame(RootingStatbyTreat)

#Populate matrix
RootingStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(RootingStatbyTreat), split="_"),"[[",1)
RootingStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(RootingStatbyTreat)[2:nrow(RootingStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(RootingStatbyTreat)[i])
  RootingStatbyTreat$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep=" ")
  RootingStatbyTreat$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro rooting for shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates +/- standard deviation; Av. No. of roots (Average number of roots per shoot tip): mean +/- standard deviation.")
```

# Step 3: Comparative analyses on rooting data {#step3}

The input variables for these analyses are stored in `MERGE`.

## Statistical analyses on root data

Please find below the analyses conducted on root (count data) and callus (binary) data.

### Testing for normality {.tabset .tabset-pills}

#### Analyses

Before conducting statistical analyses, we have to test for normality of the rooting data (count) by using the Shapiro-Wilk normality test implemented in the R base function `shapiro.test()`. A *p*-value <= 0.01 is will be used for significance.

```{r normalitytest, eval=T, echo=F}
###~~~
#Conducting Shapiro-Wilk normality test on root data
###~~~

#Rooting data
shapiro.test(MERGE$Root)
```

This test strongly rejects normality. The visualization of the data (Figure \@ref(fig:distrRoot)) together with the low mean (`r round(mean(MERGE$Root),2)`) confirm that the root count data does not approximate a normal distribution. This is often because these type of data are truncated at zero, that is, negative values are impossible and the distribution is therefore skewed to the right. This is confirmed by the skewness coefficient of `r round(skewness(MERGE$Root, na.rm = TRUE),2)`, which demonstrates that the data has a positively skewed distribution (see Figure \@ref(fig:distrRoot)). Square-root or log transformation methods could be applied to normalize the data, but those are not applicable with zero values. In this context, we are opting to conduct non-parametric analyses.

```{r distrRoot, echo=F, eval=T, fig.cap="Distribution of number of roots per shoot tips"}
hist(MERGE$Root, xlab="Number of roots per shoot tip", main="")
```

#### R code

```{r normalitytestcode, eval=F, echo=T}
###~~~
#Conducting Shapiro-Wilk normality test on root data
###~~~

#Rooting data
shapiro.test(MERGE$Root)

###~~~
#Visualize root (count) data
###~~~
hist(MERGE$Root, xlab="Number of roots per shoot tip", main="")

###~~~
#Mean of root (count) data
###~~~

###~~~
#Skewness coefficient of root (count) data
###~~~
skewness(MERGE$Root, na.rm = TRUE)
```

### Selecting the best method {.tabset .tabset-pills}

#### Rationale

A shown above, non-parametric analyses have to be conducted on the root (count) data. In this context, we can analyze our data using either general linear models (GLMs) or the Kruskal-Wallis rank sum test. In this study, we aim at:

1. Testing whether a treatment is better suited to promote rooting of shoot tips.
2. Testing whether some individuals have higher rooting rates independently to treatment (those would be used as candidate for genome sequencing and/or GxE research).

Both of these aims require ranking variables. Figure \@ref(fig:distrRoot) suggests that the Poisson model would best fit the data for the GLM analyses; however it is skewed towards zero (with the highest frequency), which is problematic with classic GLM models. In this context, we are advocating for using the zero-inflated count data regression approach as implemented in the `pscl` R package [@R-pscl] to analyze the rooting data. This approach fits zero-inflated regression models for count data via maximum likelihood (using either Poisson or Negative binomial distributions). It is not recommended that zero-inflated models be applied to small samples (see [here](https://stats.idre.ucla.edu/r/dae/zip/)). Analyses presented in section \@ref(glm) demonstrated that zero-inflated models (even with Negative binomial distribution) failed to assess individual effect on rooting most likely due to the small sample size at individual level (n=15 samples per individual). In this context, **we are opting for analyzing our data using the Kruskal-Wallis tests to test for treatment and individual effects**.

#### Zero-inflated GLM models {#glm}

As shown in Figure \@ref(fig:distrRoot) we still need to test what model best fit the data. Here, we will be investigating whether treatment and individual affect rooting using both the Poisson and Negative binary count model families. A likelihood ratio test together with dispersion statistics will be used to identify the best-fit model. Due to the inability of zero-inflated GLM models to analyze individual effects, we are opting for analyzing our data using the approach implemented in the Kruskal-Wallis test. 

```{r zeroinflRoot, echo=T, eval=T}
###~~~
#Treatment effect
###~~~
# Zero-Inflated Poisson GLM
M1 <- zeroinfl(Root ~ Treatment, dist = 'poisson', data = MERGE)

# Dispersion statistic for M1
E2 <- resid(M1, type = "pearson")
N  <- nrow(MERGE)
p  <- length(coef(M1))  
sum(E2^2) / (N - p)

# Zero-Inflated Negative Binomial GLM
M2 <- zeroinfl(Root ~ Treatment, dist = 'negbin', data = MERGE) 

# Dispersion statistic for M2
E2 <- resid(M2, type = "pearson")
N  <- nrow(MERGE)
p  <- length(coef(M2))  
sum(E2^2) / (N - p)

# Likelihood ratio test (can't apply anova on zeroinfl models)
lrtest(M1, M2)

# Summary of M2
summary(M2)


###~~~
#Ranking treatments
###~~~
# Estimated marginal means (Least-squares means) for treatments using M2
posthocRoot <- emmeans(M2, list(pairwise ~ Treatment))

# Identify significant pairwise comparisons
signRootTreat <- as.data.frame(posthocRoot$`pairwise differences of Treatment`)
signRootTreat <- signRootTreat[which(signRootTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signRootTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")

###~~~
#Individual effect
###~~~

# Zero-Inflated Negative Binomial GLM
M1 <- zeroinfl(Root ~ IndGeno, dist = 'negbin', data = MERGE) 

# Summary of M1
summary(M1)
```

### Investigating treatment effect {.tabset .tabset-pills}

#### Analyses

Here, we are applying the Kruskal-Wallis rank sum test followed by pairwise Wilcox tests to assess treatment effects and rank those (with a *p*-value of <= 0.01). Results of these analyses are presented below and the R code is available in section \@ref(RTreat). 

```{r kruskalTreat, echo=F, eval=T, message=FALSE, warning=FALSE}
# Run Kruskal-Wallis Rank Sum Test
print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Treatment")
K1Treat <- kruskal.test(Root ~ Treatment, data = MERGE)
print(K1Treat)

# Run Wilcox test on Root ~ Treatment
print("Perform Wilcox test on Root ~ Treatment")
wilcoxRootTreat <- pairwise.wilcox.test(MERGE$Root, MERGE$Treatment,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootTreat <- wilcoxRootTreat$p.value

# Convert distance matrix into 3 cols: Treat1, Treat2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootTreat)){
  tmp <- wilcoxRootTreat[i,]
  tmp <- cbind(rep(rownames(wilcoxRootTreat)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Treat1", "Treat2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Treatment effect
Treat <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per treatment
meanRoot <- aggregate(Root ~ Treatment, mean, data = MERGE)

# Diff of means Treat1-Treat2
Treat$Diff_mean <- round(meanRoot[match(Treat[,1], meanRoot[,1]),2]-meanRoot[match(Treat[,2], meanRoot[,1]),2],2)

# Plot table
knitr::kable(Treat, caption = "Results of Wilcox test on Root ~ Treatment (p-value <= 0.01).")
```

Table \@ref(tab:kruskalTreat) allows ranking treatments as follows (from best to worst):

- `IBA_1`: a
- `IBA_05`: ab
- `NAA_1`: b
- `NAA_05`: b
- `Control`: c

##### Boxplot of rooting by treatment

To support further visual comparison of rooting by treatment, a boxplot was inferred based on the merged dataset (`MERGE`). Figure \@ref(fig:boxplot1) supports ranking from the statistical analysis (Table \@ref(tab:kruskalTreat) and would suggest that `IBA_1` is the most efficient treatment to initiate rooting in sagebrush with a median value of 1 root per tip (whereas other treatments have their median at 0).

```{r boxplot1, echo=F, eval=T, fig.cap="Boxplot comparing number of roots per shoot tip of diploid Artemisia tridentata subsp. tridentata sorted by treatment. Rankings are based on the pairwise least-square means analysis.", out.width="100%"}
###~~~
#Boxplot comparing rooting per treatment
###~~~

# Draw boxplot
boxplot(MERGE$Root ~ MERGE$Treatment, xlab = "Treatment", ylab = "Number of roots per shoot tip", ylim=c(0,12.5), names = c("Control", "IBA 0.5 mg/l", "IBA 1 mg/l", "NAA 0.5 mg/l", "NAA 1 mg/l"))

# Add ranking based on Tukey tests
text(x=c(1,2,3,4,5), y=rep(12.5,5), c("c","ab","a",'b','b'))
```

#### R code {#RTreat}

```{r kruskalTreatcode, echo=T, eval=F, message=FALSE, warning=FALSE}
###~~~
# Run Kruskal-Wallis Rank Sum Test
###~~~

print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Treatment")
K1Treat <- kruskal.test(Root ~ Treatment, data = MERGE)
print(K1Treat)

###~~~
# Run Wilcox test on Root ~ Treatment
###~~~

print("Perform Wilcox test on Root ~ Treatment")
wilcoxRootTreat <- pairwise.wilcox.test(MERGE$Root, MERGE$Treatment,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootTreat <- wilcoxRootTreat$p.value

# Convert distance matrix into 3 cols: Treat1, Treat2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootTreat)){
  tmp <- wilcoxRootTreat[i,]
  tmp <- cbind(rep(rownames(wilcoxRootTreat)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Treat1", "Treat2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Treatment effect
Treat <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per treatment
meanRoot <- aggregate(Root ~ Treatment, mean, data = MERGE)

# Diff of means Treat1-Treat2
Treat$Diff_mean <- round(meanRoot[match(Treat[,1], meanRoot[,1]),2]-meanRoot[match(Treat[,2], meanRoot[,1]),2],2)

# Plot table
knitr::kable(Treat, caption = "Results of Wilcox test on Root ~ Treatment (p-value <= 0.01).")

###~~~
#Boxplot comparing rooting per treatment
###~~~

# Draw boxplot
boxplot(MERGE$Root ~ MERGE$Treatment, xlab = "Treatment", ylab = "Number of roots per shoot tip", ylim=c(0,12.5), names = c("Control", "IBA 0.5 mg/l", "IBA 1 mg/l", "NAA 0.5 mg/l", "NAA 1 mg/l"))

# Add ranking based on Tukey tests
text(x=c(1,2,3,4,5), y=rep(12.5,5), c("c","ab","a",'b','b'))
```

### Investigate individual effect {.tabset .tabset-pills}

#### Analyses

Here, we are applying the Kruskal-Wallis rank sum test followed by pairwise Wilcox tests to assess individual effects and rank those (with a *p*-value of <= 0.01). Results of these analyses are presented below and the R code is available in section \@ref(RInd). To qualify as a top performer, an individual has to outperform >= 20% of individuals (based on pairwise Wilcox tests with a *p*-value <= 0.01).

```{r kruskalInd, echo=F, eval=T, message=FALSE, warning=FALSE}
###~~~
# Run Kruskal-Wallis Rank Sum Test
###~~~

print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Individual")
K1 <- kruskal.test(Root ~ IndGeno, data = MERGE)
print(K1)

###~~~
# Run Wilcox test on Root ~ IndGeno
###~~~

print("Perform Wilcox test on Root ~ Individual")
wilcoxRootInd <- pairwise.wilcox.test(MERGE$Root, MERGE$IndGeno,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootInd <- wilcoxRootInd$p.value

# Convert distance matrix into 3 cols: ind1, ind2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootInd)){
  tmp <- wilcoxRootInd[i,]
  tmp <- cbind(rep(rownames(wilcoxRootInd)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Ind1", "Ind2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Individual effect
IndRoot <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per individual
meanRoot <- aggregate(Root ~ IndGeno, mean, data = MERGE)

# Diff of means Ind1-Ind2
IndRoot$Diff_mean <- meanRoot[match(IndRoot[,1], meanRoot[,1]),2]-meanRoot[match(IndRoot[,2], meanRoot[,1]),2]

# What are the top performers (= most efficient at producing roots)?
IndRootOut <- IndRoot[which(IndRoot$Diff_mean > 0),]

# Percentage of individuals that are outperformed by P1
TopInd <- 100*(sort(table(IndRootOut[,1]), decreasing=T)/length(unique(MERGE$IndGeno)))

# Select only ind that are outperforming at least 20% of individuals 
TopInd <- TopInd[which(TopInd >= 20)]

TopInd <- as.matrix(round(TopInd, 1))
colnames(TopInd) <- c("Percentage of individuals outperformed")

# Plot table
knitr::kable(TopInd, caption = "List of individual that are outperforming at least 20% of individuals (based on Wilcoxon rank sum tests on Individual variable with a pval <= 0.01).")
```

The analyses reported in Table \@ref(tab:kruskalInd) demonstrate that only two individuals (`r rownames(TopInd)`, which are referred to as P1 and P2) are significantly outperforming at least 20% of the individuals based on their rooting abilities independently to treatment.

#### R code {#RInd}

```{r kruskalIndcode, echo=T, eval=F, message=FALSE, warning=FALSE}
###~~~
# Run Kruskal-Wallis Rank Sum Test
###~~~

print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Individual")
K1 <- kruskal.test(Root ~ IndGeno, data = MERGE)
print(K1)

###~~~
# Run Wilcox test on Root ~ IndGeno
###~~~

print("Perform Wilcox test on Root ~ Individual")
wilcoxRootInd <- pairwise.wilcox.test(MERGE$Root, MERGE$IndGeno,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootInd <- wilcoxRootInd$p.value

# Convert distance matrix into 3 cols: ind1, ind2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootInd)){
  tmp <- wilcoxRootInd[i,]
  tmp <- cbind(rep(rownames(wilcoxRootInd)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Ind1", "Ind2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Individual effect
IndRoot <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per individual
meanRoot <- aggregate(Root ~ IndGeno, mean, data = MERGE)

# Diff of means Ind1-Ind2
IndRoot$Diff_mean <- meanRoot[match(IndRoot[,1], meanRoot[,1]),2]-meanRoot[match(IndRoot[,2], meanRoot[,1]),2]

# What are the top performers (= most efficient at producing roots)?
IndRootOut <- IndRoot[which(IndRoot$Diff_mean > 0),]

# Percentage of individuals that are outperformed by P1
TopInd <- 100*(sort(table(IndRootOut[,1]), decreasing=T)/length(unique(MERGE$IndGeno)))

# Select only ind that are outperforming at least 20% of individuals 
TopInd <- TopInd[which(TopInd >= 20)]

TopInd <- as.matrix(round(TopInd, 1))
colnames(TopInd) <- c("Percentage of individuals outperformed")

# Plot table
knitr::kable(TopInd, caption = "List of individual that are outperforming at least 20% of individuals (based on Wilcoxon rank sum tests on Individual variable with a pval <= 0.01).")
```

## Clustering analysis on rooting data {.tabset .tabset-pills}

### Analyses

A clustering analysis was used to compare rooting performance between individuals based on an euclidean distance (using the `Root` count data; see section \@ref(Rclustroot) for R code). This analysis sorted individuals into rooting clusters based on their abilities to initiate rooting (which is also shown by the heatmap). Finally, to performer individuals (P1 and P2) identified by the statistical analyses are also represented on the graph. The code used to produce these analyses is available below. The analysis clearly distinguished three clusters (of even number of individuals; see Table \@ref(tab:tablegroups)) based on individual rooting performances (Figure \@ref(fig:heatmap2)):

- Black cluster: No to very little rooting.
- Pink cluster: Some rooting observed.
- Blue cluster: Most individuals are exhibiting high rooting capacity and the top three performers belong to this cluster.

```{r heatmap2, echo=F, eval=T, fig.cap="Heatmap comparing calli production of shoot tips of diploid Artemisia tridentata subsp. tridentata showing three clusters, which are not identical to those inferred with rooting data. The position of top performers as identified by the Tukey tests on rooting data is also displayed.", out.width="100%"}
knitr::include_graphics("03_Figures_report/Fig_2_Heatmap_compare_ind_rooting.png")
```

The number of individual per rooting clusters inferred from the clustering analysis is displayed in Table \@ref(tab:tablegroups). The R code to generate this table is in section \@ref(Rclustroot).

```{r tablegroups, echo=F, eval=T}
###~~~
#Produce pivot table with number of individual per group and genotype composition
###~~~
# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# colInd add Genotypes
colInd$Genotype <- sapply(strsplit(as.vector(colInd$Individual), split="_"), "[[", 1)
tabGroup <- table(colInd$Group, colInd$Genotype)
tabGroup <- tabGroup[c(1,3,2),]
tabGroup <- as.data.frame.matrix(tabGroup)
tabGroup$TOT <- rowSums(tabGroup)

# Plot table
knitr::kable(tabGroup, row.names=T, caption = "Table summarizing composition of clusters based on rooting data.")
```

#### Effect of growth regulators on *in vitro* rooting sorted by clusters

Table \@ref(tab:growthbyregulatorcluster) shows that IBA at both concentrations seem to have a significant effect on rooting for individuals belonging to the blue cluster (Figure \@ref(fig:heatmap2)). Responses are very high (both at 87.18%) and the number of roots per tip are 2.97 +/- 2.25 for IBA 0.5 and 3.59 +/- 3.41 for IBA 1 (Table \@ref(tab:growthbyregulatorcluster)). The R code to generate this table is in section \@ref(Rclustroot).

```{r growthbyregulatorcluster, echo=F, eval=T}
#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
treat <- sort(unique(MERGE$Treatment))

#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatC <- matrix(ncol=6, nrow=15)
colnames(RootingStatbyTreatC) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots", "Treatment")

#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

#Convert to dataframe
RootingStatbyTreatC <- as.data.frame(RootingStatbyTreatC)

#Populate matrix
RootingStatbyTreatC$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatC$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatC$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatC$Treatment <- rep(treat, 3)

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreatC)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatC$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatC$Cluster[i])
  RootingStatbyTreatC$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep= " ")
  RootingStatbyTreatC$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreatC[,1:5], row.names=F, caption = "Effect of growth regulator on in vitro rooting of Artemisia tridentata sorted by cluster. Response: mean of the three replicates +/- standard deviation; Av. No. of roots: mean +/- standard deviation.")
```

This will be investigated by looking at top performer individuals identified by i) statistical analyses and ii) clustering analysis.

### R code {#Rclustroot}

```{r codeclustRoot, echo=T, eval=F}
###~~
#Clustering analysis on rooting data
###~~~

# Create our own color palette from green to red for heatmap
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = 299)

# Input data for clustering and heatmap
mat_data <- table(MERGE$IndGeno, MERGE$Root)

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Annotate best perfoming individuals and add P1, P2
toAdd <- which(rownames(mat_data) %in% rownames(TopInd))
rownames(mat_data)[toAdd] <- paste0(rownames(mat_data)[toAdd], c(" (P1)", " (P2)"))

pdf("03_Figures_report/Fig_2_Heatmap_compare_ind_rooting.pdf")
# Perform clustering/heatmap and draw plot
heatmap.2(mat_data,
          cellnote = mat_data, # same data set for cell labels
          main = "", # heat map title
          notecol="black",      # change font color of cell labels to black
          notecex = .8, # cex of numbers in cells
          density.info="none",  # turns off density plot inside color legend
          trace="none",         # turns off trace lines inside the heat map
          xlab = 'N. roots per tip (1 ind. has 15 tips)', #Label of x axis
          cexRow = .8, # cex of rows (= samples ID)
          margins =c(4,9),     # widens margins around plot
          col=my_palette,       # use on color palette defined earlier
          #breaks=col_breaks,    # enable color transition at specified limits
          dendrogram="row", # only draw a row dendrogram
          key=F,
          keysize = 0.4,
          RowSideColors = as.vector(colInd$Group),
          Colv="NA") # turn off column clustering
dev.off()

###~~~
#Produce pivot table with number of individual per group and genotype composition
###~~~
# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

###~~~
#Effect of growth regulators on *in vitro* rooting sorted by clusters
###~~~
# colInd add Genotypes
colInd$Genotype <- sapply(strsplit(as.vector(colInd$Individual), split="_"), "[[", 1)
tabGroup <- table(colInd$Group, colInd$Genotype)
tabGroup <- tabGroup[c(1,3,2),]
tabGroup <- as.data.frame.matrix(tabGroup)
tabGroup$TOT <- rowSums(tabGroup)

# Plot table
knitr::kable(tabGroup, row.names=T, caption = "Table summarizing composition of clusters based on rooting data.")

#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
treat <- sort(unique(MERGE$Treatment))

#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatC <- matrix(ncol=6, nrow=15)
colnames(RootingStatbyTreatC) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots", "Treatment")

#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

#Convert to dataframe
RootingStatbyTreatC <- as.data.frame(RootingStatbyTreatC)

#Populate matrix
RootingStatbyTreatC$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatC$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatC$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatC$Treatment <- rep(treat, 3)

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreatC)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatC$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatC$Cluster[i])
  RootingStatbyTreatC$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep= " ")
  RootingStatbyTreatC$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}

#Plot table
knitr::kable(RootingStatbyTreatC[,1:5], row.names=F, caption = "Effect of growth regulator on in vitro rooting of Artemisia tridentata sorted by cluster. Response: mean of the three replicates +/- standard deviation; Av. No. of roots: mean +/- standard deviation.")

```

## Statistical analyses on callus data 

### Selecting the best method

Table \@ref(tab:growthbyregulatorcallus) demonstrated that >70% of shoot tips undergoing growth regulator treatments developed calli, whereas those in the control treatment had very limited calli development (< 3%). This preliminary result strongly suggested that calli were induced by growth regulators and we will be testing this hypothesis using statistical analyses.

The callus data were scored as binary (0 = absent; 1 = present) and the distribution of that data is in Figure \@ref(fig:distrCall).

```{r distrCall, echo=T, eval=T, fig.cap="Barplot of callus production during the rooting experiment."}
barplot(table(MERGE$Callus), xlab="Binary data on callus", ylab="Occurrence")
```

This type of data calls for the use of non-parametric analyses as done for the root (count) data. In this context, we will use GLM models to assess treatment and individual effects on callus production.

### Investigate treatment and individual effects {.tabset .tabset-pills}

#### Analyses

We start by comparing GLM models investigating the effects of treatment and individual on callus production. The R code is available in section \@ref(RcodeCallus).

```{r callusmodels, echo=F, eval=T}
# GLM to investigate treatment effect on callus production
M1cal <- glm(Callus ~ Treatment, family = binomial(link="logit"), data = MERGE)

# GLM to investigate treatment and individual effects on callus production
M2cal <- glm(Callus ~ Treatment + IndGeno, family = binomial(link="logit"), data = MERGE)

# Which model best fit the data?
anova(M1cal, M2cal, test = "Chisq")

# M2 better fits the data, but is it not over fitting it?
pchisq(M2cal$deviance, M2cal$df.residual, lower.tail = F)

# Summary M2
print(summary(M2cal))
```

The analyses demonstrate that there is significant treatment and individual effects.

##### Ranking treatments

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01; the R code is available in section \@ref(RcodeCallus)):

```{r emmeansCal, eval=T, echo=F}
# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallus <- emmeans(M2cal, list(pairwise ~ Treatment))

# Identify significant pairwise comparisons
signCalTreat <- as.data.frame(posthocCallus$`pairwise differences of Treatment`)
signCalTreat <- signCalTreat[which(signCalTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

Table \@ref(tab:emmeansCal) summarizes statistical comparison of treatments focusing on significant effects. These analyses are not entirely conclusive, but they demonstrate that:

- (a) Control is significantly different than the other treatments (`***`). Here, very limited calli production was observed in shoot tips included in the control treatment.
- (b) No significant differences between IBA_1, IBA_05, NAA_01 and NAA_05.

##### Ranking individuals

We are using the same approach as with the treatment to perform pairwise comparisons to identify individuals that are significantly producing calli independently of treatment. The tests concluded that although the GLM supported some individual effect, none of the individuals are significantly different based on the post hoc tests. The R code is available in section \@ref(RcodeCallus).

```{r emmeansCalInd, eval=T, echo=F}
# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallusInd <- emmeans(M2cal, list(pairwise ~ IndGeno))

# Identify significant pairwise comparisons
signCalTreatInd <- as.data.frame(posthocCallusInd$`pairwise differences of IndGeno`)
signCalTreatInd <- signCalTreatInd[which(signCalTreatInd$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreatInd, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

#### R code {#RcodeCallus}

```{r callusGLMR, echo=T, eval=F}
###~~~
#GLMs
###~~~

# GLM to investigate treatment effect on callus production
M1cal <- glm(Callus ~ Treatment, family = binomial(link="logit"), data = MERGE)

# GLM to investigate treatment and individual effects on callus production
M2cal <- glm(Callus ~ Treatment + IndGeno, family = binomial(link="logit"), data = MERGE)

# Which model best fit the data?
anova(M1cal, M2cal, test = "Chisq")

# M2 better fits the data, but is it not over fitting it?
pchisq(M2cal$deviance, M2cal$df.residual, lower.tail = F)

# Summary M2
print(summary(M2cal))

###~~~
#Ranking treatments
###~~~

# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallus <- emmeans(M2cal, list(pairwise ~ Treatment))

# Identify significant pairwise comparisons
signCalTreat <- as.data.frame(posthocCallus$`pairwise differences of Treatment`)
signCalTreat <- signCalTreat[which(signCalTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")

###~~~
#Ranking individuals
###~~~

# Estimated marginal means (Least-squares means) for treatments using M2
posthocCallusInd <- emmeans(M2cal, list(pairwise ~ IndGeno))

# Identify significant pairwise comparisons
signCalTreatInd <- as.data.frame(posthocCallusInd$`pairwise differences of IndGeno`)
signCalTreatInd <- signCalTreatInd[which(signCalTreatInd$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreatInd, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons.")
```

## Clustering analysis on callus data {.tabset .tabset-pills}

### Analyses

The code to produce the clustering analysis based on `Callus` data and associated heatmap is provided below and Figure \@ref(fig:heatmapplot) shows results of the analysis. Outcomes of this analysis are:

- Three clusters based on calli production:
  + Bottom cluster has individuals with no to very limited calli production.
  + Intermediate cluster has individuals with 50/50 calli production.
  + Top cluster has individuals with individuals producing calli.
- Clusters from the rooting analysis are not recovered here (each calli cluster are composed by a mixture of clusters from the rooting analysis). This suggests that calli production do not inhibit rooting.
- To performer individuals are shared between the intermediate and top clusters (supporting previous statement).

Please see section \@ref(Rcodecallusclust) for more details on R code.

```{r heatmapplot, echo=F, eval=T, fig.cap="Heatmap comparing calli production of sagebrush individuals showing three clusters, which are not identical to those inferred with rooting data. The position of top performers as identifed by the Tukey tests is also displayed.", out.width="100%"}
knitr::include_graphics("03_Figures_report/Fig_3_Heatmap_compare_ind_callus.png")
```

#### Effect of growth regulators on *in vitro* calli production in *Artemisia tridentata* sorted by rooting clusters

Table \@ref(tab:growthbyregulatorclustercallus) shows that IBA at both concentrations seem to have a significant effect on calli production for individuals belonging to the blue cluster (Figure \@ref(fig:heatmap2)). The R code is available in section \@ref(Rcodecallusclust).

```{r growthbyregulatorclustercallus, echo=F, eval=T}
###~~~
#Effect of growth regulators on calli production sorted by rooting cluster
###~~~

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Create vector of treatments
treat <- sort(unique(MERGE$Treatment))

# Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatCal <- matrix(ncol=5, nrow=15)
colnames(RootingStatbyTreatCal) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Treatment")

# Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

# Convert to dataframe
RootingStatbyTreatCal <- as.data.frame(RootingStatbyTreatCal)

# Populate matrix
RootingStatbyTreatCal$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatCal$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatCal$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatCal$Treatment <- rep(treat, 3)

# Infer Response
for(i in 1:nrow(RootingStatbyTreatCal)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatCal$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatCal$Cluster[i])
  RootingStatbyTreatCal$`Response (%)`[i] <- round(100*(mean(foo$Callus)),2)
}

#Plot table
knitr::kable(RootingStatbyTreatCal[,1:5], row.names=F, caption = "Effect of growth regulators on in vitro calli production on shoot tips of diploid Artemisia tridentata subsp. tridentata sorted by rooting clusters. Response: mean of the three replicates.")
```

### R code {#Rcodecallusclust}

```{r Rcodecallusclust, echo=T, eval=F}
###~~~
#Clustering analysis on calli data
###~~~

# Create our own color palette from green to red for heatmap
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = 299)

#Input data for heatmap
mat_data <- table(MERGE$IndGeno, MERGE$Callus)

#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

#Annotate best perfoming individuals (based on Tukey test) and add P1, P2
toAdd <- which(rownames(mat_data) %in% rownames(TopInd))
rownames(mat_data)[toAdd] <- paste0(rownames(mat_data)[toAdd], c(" (P1)", " (P2)"))

pdf("03_Figures_report/Fig_3_Heatmap_compare_ind_callus.pdf")
#Draw plot
heatmap.2(mat_data,
                 cellnote = mat_data, # same data set for cell labels
                 main = "", # heat map title
                 notecol="black",      # change font color of cell labels to black
                 notecex = .8, # cex of numbers in cells
                 density.info="none",  # turns off density plot inside color legend
                 trace="none",         # turns off trace lines inside the heat map
                 xlab = 'Presence (1) / absence (0) of callus in tip', #Label of x axis
                 cexRow = .8,
          cexCol = .9,# cex of rows (= samples ID)
                 margins =c(4,9),     # widens margins around plot
                 col=my_palette,       # use on color palette defined earlier
                 #breaks=col_breaks,    # enable color transition at specified limits
                 dendrogram="row", # only draw a row dendrogram
                 key=F,
                 keysize = 0.4,
                 RowSideColors = as.vector(colInd$Group),
                 Colv="NA")
dev.off()

###~~~
#Effect of growth regulators on calli production sorted by rooting cluster
###~~~

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Create vector of treatments
treat <- sort(unique(MERGE$Treatment))

# Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatCal <- matrix(ncol=5, nrow=15)
colnames(RootingStatbyTreatCal) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Treatment")

# Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

# Convert to dataframe
RootingStatbyTreatCal <- as.data.frame(RootingStatbyTreatCal)

# Populate matrix
RootingStatbyTreatCal$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatCal$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatCal$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatCal$Treatment <- rep(treat, 3)

# Infer Response
for(i in 1:nrow(RootingStatbyTreatCal)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatCal$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatCal$Cluster[i])
  RootingStatbyTreatCal$`Response (%)`[i] <- round(100*(mean(foo$Callus)),2)
}

#Plot table
knitr::kable(RootingStatbyTreatCal[,1:5], row.names=F, caption = "Effect of growth regulators on in vitro calli production on shoot tips of diploid Artemisia tridentata subsp. tridentata sorted by rooting clusters. Response: mean of the three replicates.")
```

# Step 4: *In vitro* survival and growth of plantules {#step4}

## Sampling and preliminary analyses {.tabset .tabset-pills}

### Analyses

Data on survival and plantlets heights are stored in `01_Raw_Data/Survival_height_clones.csv`. The code below provides statistics on the number of individual and shoot tips included in this experiment. The R code for these analyses is available in section \@ref(codesurv).

```{r statgrowth, echo=F, eval=T}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

###~~~
#How many individuals where transfered corresponding how many shoot tips
###~~~
stats <- matrix(ncol=1, nrow=4)
colnames(stats) <- "Sampling"
rownames(stats) <- c("Total N. ind.", "N. ind. per gen,","Total N. shoot tips", "N. shoot tips per gen.")

#Add N ind and N shoot tips
stats[c(1,3),] <- c(length(unique(survheig$SeedID)), sum(table(survheig$SeedID)))

#Tot ind per genotypes
totindgen <- table(sapply(strsplit(as.vector(unique(survheig$SeedID)), "_"), '[[', 1))
stats[2,1] <- paste0(paste0(names(totindgen), ":"), totindgen, collapse = '/')

#N shoot per genotypes
totgenshoot <- table(sapply(strsplit(as.vector(survheig$SeedID), "_"), '[[', 1))
stats[4,1] <- paste0(paste0(names(totgenshoot), ":"), totgenshoot, collapse = '/')


print(stats)

###~~~
#Breakdown of number of shoot tips per individual
###~~~

#Sort based on number of shoot tips
sort(table(survheig$SeedID), decreasing=T)
```

#### Survival and plantlets heights

Results of the code provided below is summarized in Table \@ref(tab:surv). After 5 weeks, a survival of 53.48% of the plantlets was observed. A significant increase of plantlets mortality has been recorded between weeks 3 and 5 and on average, plantlets did not growth significant (but see below for more details).   

```{r surv, echo=F, eval=T}
###~~~
# Matrix to store data @ 3 and 5 weeks
###~~~
survheigStat <- matrix(ncol=2, nrow = 2)
colnames(survheigStat) <- c("Survival (%)", "Plant height (cm)")
rownames(survheigStat) <- c("Week 3", "Week 5")

###
#3 weeks
###

# Survivial
ThreeWsurvAll <- table(survheig$X3_w_survival)
survheigStat[1,1] <- round(100*((sum(ThreeWsurvAll)-ThreeWsurvAll[which(names(ThreeWsurvAll) == 0)])/sum(ThreeWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[1,2] <- paste0(round(mean(survheig$X3_w_height),2), "+/-", round(sd(survheig$X3_w_height),2))

###
#5 weeks
###

# Survivial
FiveWsurvAll <- table(survheig$X5_w_survival)
survheigStat[2,1] <- round(100*((sum(FiveWsurvAll)-FiveWsurvAll[which(names(FiveWsurvAll) == 0)])/sum(FiveWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[2,2] <- paste0(round(mean(survheig$X5_w_height),2), "+/-", round(sd(survheig$X5_w_height),2))


# Plot table
knitr::kable(survheigStat, row.names=T, caption = "Survival and plantlets heights at 3 and 5 weeks (+/- standard deviations).")
```

#### Survival and plantlets heights by rooting clusters

Table \@ref(tab:survclust) shows data on survival, plantlets heights at 3 and 5 weeks sorted by rooting clusters. Data on the number of individuals and shoot tips included in this experiment for each rooting cluster is also provided. 

```{r survclust, echo=F, eval=T}
###
#Create list of clusters
###
clust <- sort(unique(survheig$Cluster))[c(1,3,2)]

###~~~
#Matrix with data on cluster, N. ind, N. shoot tips, survival and height
###~~~
clustSurvHeig <- matrix(ncol=7, nrow = length(clust))
colnames(clustSurvHeig) <- c("Rooting cluster", "N. ind.","N. shoot tips", "3 w. surv. (%)", "3 w. plant height (cm)", "5 w. surv. (%)", "5 w. plant height (cm)")
clustSurvHeig[,1] <- as.character(clust)

for(i in 1:length(clust)){
  #Subset mat to clust
  tmp <- subset(survheig, survheig$Cluster == clust[i])
  
  ###
  #3 weeks
  ###
  #N. ind.
  clustSurvHeig[i,2] <- length(unique(tmp$SeedID))
  #N. shoot tips
  clustSurvHeig[i,3] <- nrow(tmp)
  #Survivial
  ThreeWsurv <- table(tmp$X3_w_survival)
  clustSurvHeig[i,4] <- round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,5] <- paste0(round(mean(tmp$X3_w_height),2), "+/-", round(sd(tmp$X3_w_height),2))
  
  ###
  #5 weeks
  ###
  #Survivial
  FiveWsurv <- table(tmp$X5_w_survival)
  clustSurvHeig[i,6] <- round(100*((sum(FiveWsurv)-FiveWsurv[which(names(FiveWsurv) == 0)])/sum(FiveWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,7] <- paste0(round(mean(tmp$X5_w_height),2), "+/-", round(sd(tmp$X5_w_height),2))
}

#Plot table
knitr::kable(clustSurvHeig, row.names=F, caption = "Survival and plantlets heights at 3 and 5 weeks sorted by rooting clusters.")
```

#### Survival and plantlets heights by rooting clusters and treatments

Table \@ref(tab:survclusttreat) shows survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.

```{r survclusttreat, echo=F, eval=T}
###~~~
#Split survheig$Treatment to extract growth regulator and concentration
###~~~
survheig$TreatConc <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 2), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 3), sep="_")
survheig$TreatConc[grep("Control_", survheig$TreatConc)] <- "Control"

#Vector of treatments
treat <- sort(unique(survheig$TreatConc))

###~~~
#Matrix summarizing effect of growth regulators on rooting
###~~~
survheigTreat <- matrix(ncol=8, nrow=15)
colnames(survheigTreat) <- c("Cluster", "N. ind.","N. shoot tips","Growth regulator", "Concentration (mg/l)", "Survival (%)", "Height (cm)", "Treatment")

#Convert to dataframe
survheigTreat <- as.data.frame(survheigTreat)

#Populate matrix
survheigTreat$Cluster <- sort(rep(clust,5))
survheigTreat$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
survheigTreat$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
survheigTreat$Treatment <- rep(treat, 3)

#Infer N, surv and plant height
for(i in 1:nrow(survheigTreat)){
  foo <- subset(survheig, survheig$TreatConc == survheigTreat$Treatment[i] & survheig$Cluster == survheigTreat$Cluster[i])
  
  if(nrow(foo) > 0){
    #N. ind.
    survheigTreat$`N. ind.`[i] <- length(unique(foo$SeedID))
    #N. shoot tips
    survheigTreat$`N. shoot tips`[i] <- nrow(foo)
    #Survivial
    ThreeWsurv <- table(foo$X5_w_survival)
    survheigTreat$`Survival (%)`[i] <-   round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
    #Mean plant height +/- sd
    survheigTreat$`Height (cm)`[i] <- paste0(round(mean(foo$X5_w_height),2), "+/-", round(sd(foo$X5_w_height),2))  
  }
  
}

#Save to be included in manuscript
#write.csv(survheigTreat, file='Survival_cluster_treatment_5w.csv')

#Plot table
knitr::kable(survheigTreat, row.names=F, caption = "Survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.")
```

### R code {#codesurv}

```{r codesurv, echo=T, eval=F}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

###~~~
#How many individuals where transfered corresponding how many shoot tips
###~~~
stats <- matrix(ncol=1, nrow=4)
colnames(stats) <- "Sampling"
rownames(stats) <- c("Total N. ind.", "N. ind. per gen,","Total N. shoot tips", "N. shoot tips per gen.")

#Add N ind and N shoot tips
stats[c(1,3),] <- c(length(unique(survheig$SeedID)), sum(table(survheig$SeedID)))

#Tot ind per genotypes
totindgen <- table(sapply(strsplit(as.vector(unique(survheig$SeedID)), "_"), '[[', 1))
stats[2,1] <- paste0(paste0(names(totindgen), ":"), totindgen, collapse = '/')

#N shoot per genotypes
totgenshoot <- table(sapply(strsplit(as.vector(survheig$SeedID), "_"), '[[', 1))
stats[4,1] <- paste0(paste0(names(totgenshoot), ":"), totgenshoot, collapse = '/')


print(stats)

###~~~
#Breakdown of number of shoot tips per individual
###~~~

#Sort based on number of shoot tips
sort(table(survheig$SeedID), decreasing=T)

###~~~
# Matrix to store data @ 3 and 5 weeks
###~~~
survheigStat <- matrix(ncol=2, nrow = 2)
colnames(survheigStat) <- c("Survival (%)", "Plant height (cm)")
rownames(survheigStat) <- c("Week 3", "Week 5")

###
#3 weeks
###

# Survivial
ThreeWsurvAll <- table(survheig$X3_w_survival)
survheigStat[1,1] <- round(100*((sum(ThreeWsurvAll)-ThreeWsurvAll[which(names(ThreeWsurvAll) == 0)])/sum(ThreeWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[1,2] <- paste0(round(mean(survheig$X3_w_height),2), "+/-", round(sd(survheig$X3_w_height),2))

###
#5 weeks
###

# Survivial
FiveWsurvAll <- table(survheig$X5_w_survival)
survheigStat[2,1] <- round(100*((sum(FiveWsurvAll)-FiveWsurvAll[which(names(FiveWsurvAll) == 0)])/sum(FiveWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[2,2] <- paste0(round(mean(survheig$X5_w_height),2), "+/-", round(sd(survheig$X5_w_height),2))


# Plot table
knitr::kable(survheigStat, row.names=T, caption = "Survival and plantlets heights at 3 and 5 weeks (+/- standard deviations).")

###
#Create list of clusters
###
clust <- sort(unique(survheig$Cluster))[c(1,3,2)]

###~~~
#Matrix with data on cluster, N. ind, N. shoot tips, survival and height
###~~~
clustSurvHeig <- matrix(ncol=7, nrow = length(clust))
colnames(clustSurvHeig) <- c("Rooting cluster", "N. ind.","N. shoot tips", "3 w. surv. (%)", "3 w. plant height (cm)", "5 w. surv. (%)", "5 w. plant height (cm)")
clustSurvHeig[,1] <- as.character(clust)

for(i in 1:length(clust)){
  #Subset mat to clust
  tmp <- subset(survheig, survheig$Cluster == clust[i])
  
  ###
  #3 weeks
  ###
  #N. ind.
  clustSurvHeig[i,2] <- length(unique(tmp$SeedID))
  #N. shoot tips
  clustSurvHeig[i,3] <- nrow(tmp)
  #Survivial
  ThreeWsurv <- table(tmp$X3_w_survival)
  clustSurvHeig[i,4] <- round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,5] <- paste0(round(mean(tmp$X3_w_height),2), "+/-", round(sd(tmp$X3_w_height),2))
  
  ###
  #5 weeks
  ###
  #Survivial
  FiveWsurv <- table(tmp$X5_w_survival)
  clustSurvHeig[i,6] <- round(100*((sum(FiveWsurv)-FiveWsurv[which(names(FiveWsurv) == 0)])/sum(FiveWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,7] <- paste0(round(mean(tmp$X5_w_height),2), "+/-", round(sd(tmp$X5_w_height),2))
}

#Plot table
knitr::kable(clustSurvHeig, row.names=F, caption = "Survival and plantlets heights at 3 and 5 weeks sorted by rooting clusters.")

###~~~
#Split survheig$Treatment to extract growth regulator and concentration
###~~~
survheig$TreatConc <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 2), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 3), sep="_")
survheig$TreatConc[grep("Control_", survheig$TreatConc)] <- "Control"

#Vector of treatments
treat <- sort(unique(survheig$TreatConc))

###~~~
#Matrix summarizing effect of growth regulators on rooting
###~~~
survheigTreat <- matrix(ncol=8, nrow=15)
colnames(survheigTreat) <- c("Cluster", "N. ind.","N. shoot tips","Growth regulator", "Concentration (mg/l)", "Survival (%)", "Height (cm)", "Treatment")

#Convert to dataframe
survheigTreat <- as.data.frame(survheigTreat)

#Populate matrix
survheigTreat$Cluster <- sort(rep(clust,5))
survheigTreat$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
survheigTreat$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
survheigTreat$Treatment <- rep(treat, 3)

#Infer N, surv and plant height
for(i in 1:nrow(survheigTreat)){
  foo <- subset(survheig, survheig$TreatConc == survheigTreat$Treatment[i] & survheig$Cluster == survheigTreat$Cluster[i])
  
  if(nrow(foo) > 0){
    #N. ind.
    survheigTreat$`N. ind.`[i] <- length(unique(foo$SeedID))
    #N. shoot tips
    survheigTreat$`N. shoot tips`[i] <- nrow(foo)
    #Survivial
    ThreeWsurv <- table(foo$X5_w_survival)
    survheigTreat$`Survival (%)`[i] <-   round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
    #Mean plant height +/- sd
    survheigTreat$`Height (cm)`[i] <- paste0(round(mean(foo$X5_w_height),2), "+/-", round(sd(foo$X5_w_height),2))  
  }
  
}

#Save to be included in manuscript
#write.csv(survheigTreat, file='Survival_cluster_treatment_5w.csv')

#Plot table
knitr::kable(survheigTreat, row.names=F, caption = "Survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.")
```

## Statistical analyses on survival data {.tabset .tabset-pills}

### Analyses

Here, we will use statistical analyses to test whether treatment or individual predict survival and heights of plantlets after 5-weeks of culture. The distribution of the survival data is in Figure \@ref(fig:distrSurv) and it supports using GLM models with a binomial family distribution (same approach than with the callus data). The R code is available in section \@ref(survcodeR).

```{r survtidy, echo=F, eval=T}
####~~~~
#Infer treatment types recieved by plantles
###~~~
survheig$Treat <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(2)), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(3)), sep="_")
survheig$Treat[grep("Control_", survheig$Treat)] <- "Control"

###~~~
#Turn survival into a binary data (sickly plantlets have a score of 0.5, but will be changed to 1)
###~~~
survheig$X5_w_survival[which(survheig$X5_w_survival == 0.5)] <- 1
```

```{r distrSurv, echo=F, eval=T, fig.cap="Barplot of survival of plantlets after 5 weeks of growth."}
barplot(table(survheig$X5_w_survival), xlab="Binary data on survival", ylab="Occurrence")
```

#### Comparing GLM models

We will be building and comparing three models as follows:

```{r survivalmodels, echo=F, eval=T}
# GLM to investigate treatment effect on survival
M1surv <- glm(X5_w_survival ~ Treat, family = binomial(link="logit"), data = survheig)
summary(M1surv)

# GLM to investigate treatment and cluster effects on survival
M2surv <- glm(X5_w_survival ~ Treat + SeedID, family = binomial(link="logit"), data = survheig)
summary(M2surv)
```

We are not pursuing our investigations any further since both models suggest that there is no significant treatment effects on survival. This means that if the shoot tips were producing roots then they had equal probabilities of survival independently of treatment. 

### R code {#survcodeR}

```{r survcode, echo=T, eval=F}
####~~~~
#Infer treatment types recieved by plantles
###~~~
survheig$Treat <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(2)), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(3)), sep="_")
survheig$Treat[grep("Control_", survheig$Treat)] <- "Control"

###~~~
#Turn survival into a binary data (sickly plantlets have a score of 0.5, but will be changed to 1)
###~~~
survheig$X5_w_survival[which(survheig$X5_w_survival == 0.5)] <- 1

###~~~
#Produce barplot of survival data
###~~~
barplot(table(survheig$X5_w_survival), xlab="Binary data on survival", ylab="Occurrence")

###~~~
#GLM models
###~~~
# GLM to investigate treatment effect on survival
M1surv <- glm(X5_w_survival ~ Treat, family = binomial(link="logit"), data = survheig)
summary(M1surv)

# GLM to investigate treatment and cluster effects on survival
M2surv <- glm(X5_w_survival ~ Treat + SeedID, family = binomial(link="logit"), data = survheig)
summary(M2surv)
```


## Statistical analyses on growth data {.tabset .tabset-pills}

Here, we will only work on alive plantlets (`survheig$X5_w_survival` == 1) and conduct statistical analyses to test whether individuals from the different rooting clusters have different growth rates. First, we have to test whether the continuous growth data follow a normal distribution using the Shapiro-Wilk normality test. The R code for all these analyses is available in section \@ref(codegrowthstat).

### Analyses

#### Test for normality

```{r normgrowth, echo=F, eval=T}
###~~~
#Subset surveigh to include only alive plantlets after 5 weeks
###~~~

#All plantlets surviving after 5 weeks of culture 
subSurvHeigh <- subset(survheig, survheig$X5_w_survival != "0")

###~~~
#Test for normality
###~~~
# The data have a normal distribution!
shapiro.test(subSurvHeigh$X5_w_height)
```

#### ANOVA analyses

```{r anovaroot, echo=F, eval=T}
###~~~
#Define ANOVA model and run analysis
###~~~
#Since it seemed that treatment had an effect
anovaOUTRoot <- aov(X5_w_height ~ Cluster + SeedID, data = subSurvHeigh)


# Summary of ANOVA
summary(anovaOUTRoot)
```

The ANOVA show significant cluster and individual effects. The Tukey tests show that individuals in the blue rooting cluster are significantly taller than those in the pink cluster (black is not shown different than blue, but it could be due to small sampling size of this cluster). Finally, `G2_b27_1` is significantly taller than 13.88% of the individuals included in this experiment. This individual was identified as a top 3 performer!  

#### Tukey tests

```{r tukeyheight, echo=F, eval=T}
###~~~
#Tukey tests on significant variables
###~~~
# Vector with significant variables (only one here)
significant_vars <- c("SeedID", "Cluster")

# Run Tukey tests
anovaOUTheight_tukey <- TukeyHSD(anovaOUTRoot, significant_vars)

# Save analysis
saveRDS(anovaOUTheight_tukey,"02_Processed_data/rds_tables/TukeyHeight.rds")

###~~~
#Investigate cluster effect (**)
###~~~
ClustTukeyHeight <- anovaOUTheight_tukey$Cluster[which(as.numeric(anovaOUTheight_tukey$Cluster[,4]) <= 0.01),]

# What are the top cluster(s) (= most efficient at growing fast)?
#ClusterTukeyHeightTop <- ClustTukeyHeight[which(ClustTukeyHeight[,1] > 0),]

print(anovaOUTheight_tukey$Cluster)
print("Blue is significantly outperforming pink!")

###~~~
#Investigate individual effect (***)
###~~~
IndTukeyHeight <- anovaOUTheight_tukey$SeedID[which(as.numeric(anovaOUTheight_tukey$SeedID[,4]) <= 0.01),]

# What are the top performers (= most efficient at growing fast)?
IndTukeyHeightTop <- IndTukeyHeight[which(IndTukeyHeight[,1] > 0),]

# Extract best performing ind (first in rownames of comparison)
P1growth <- sapply(strsplit(rownames(IndTukeyHeightTop), split='-'), "[[",1)

# Percentage of individuals that are outperformed by P1
TopIndgrowth <- 100*(sort(table(P1growth), decreasing=T)/length(unique(subSurvHeigh$SeedID)))

## This analysis shows that G2_b27_1 grows significantly faster than 14.28% of the individuals in this experiment
print(TopIndgrowth)
```

### R code {#codegrowthstat}

```{r codegrowthstatR, echo=T, eval=F}
###~~~
#Subset surveigh to include only alive plantlets after 5 weeks
###~~~

#All plantlets surviving after 5 weeks of culture 
subSurvHeigh <- subset(survheig, survheig$X5_w_survival != "0")

###~~~
#Test for normality
###~~~
# The data have a normal distribution!
shapiro.test(subSurvHeigh$X5_w_height)

###~~~
#Define ANOVA model and run analysis
###~~~
#Since it seemed that treatment had an effect
anovaOUTRoot <- aov(X5_w_height ~ Cluster + SeedID, data = subSurvHeigh)


# Summary of ANOVA
summary(anovaOUTRoot)

###~~~
#Tukey tests on significant variables
###~~~
# Vector with significant variables (only one here)
significant_vars <- c("SeedID", "Cluster")

# Run Tukey tests
anovaOUTheight_tukey <- TukeyHSD(anovaOUTRoot, significant_vars)

# Save analysis
saveRDS(anovaOUTheight_tukey,"02_Processed_data/rds_tables/TukeyHeight.rds")

###~~~
#Investigate cluster effect (**)
###~~~
ClustTukeyHeight <- anovaOUTheight_tukey$Cluster[which(as.numeric(anovaOUTheight_tukey$Cluster[,4]) <= 0.01),]

# What are the top cluster(s) (= most efficient at growing fast)?
#ClusterTukeyHeightTop <- ClustTukeyHeight[which(ClustTukeyHeight[,1] > 0),]

print(anovaOUTheight_tukey$Cluster)
print("Blue is significantly outperforming pink!")

###~~~
#Investigate individual effect (***)
###~~~
IndTukeyHeight <- anovaOUTheight_tukey$SeedID[which(as.numeric(anovaOUTheight_tukey$SeedID[,4]) <= 0.01),]

# What are the top performers (= most efficient at growing fast)?
IndTukeyHeightTop <- IndTukeyHeight[which(IndTukeyHeight[,1] > 0),]

# Extract best performing ind (first in rownames of comparison)
P1growth <- sapply(strsplit(rownames(IndTukeyHeightTop), split='-'), "[[",1)

# Percentage of individuals that are outperformed by P1
TopIndgrowth <- 100*(sort(table(P1growth), decreasing=T)/length(unique(subSurvHeigh$SeedID)))

## This analysis shows that G2_b27_1 grows significantly faster than 14.28% of the individuals in this experiment
print(TopIndgrowth)
```

## Boxplot of plantlet heights for individuals in blue rooting cluster {.tabset .tabset-pills}

### Analyses

Figure \@ref(fig:boxplotheightblue) shows the distribution of plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid *Artemisia tridentata* subsp. *tridentata*. As predicted by the statistical analyses on plantlet heights, `G2_b7_1` among the top three individuals with the fastest growth in our experiment (with `G2_b7_1` being the fastest grower and isolated as P2 in previous analyses). The top two individuals identified by the rooting analysis are also shown on the boxplot. The R code is available in section \@ref(boxgrowthcode).

```{r boxplotheightblue, echo=F, eval=T, fig.cap="Boxplot showing plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid Artemisia tridentata subsp. tridentata. The n indicates the number of plantlets cultured for each individual. The top three performers as identified by the rooting experiment are also displayed (P1, P2)."}
###~~~
#Subset to only include from blue rooting cluster
###~~~
blueHeight <- subset(subSurvHeigh, subSurvHeigh$Cluster == 'blue')

#Individual
seedID <- table(as.vector(blueHeight$SeedID))

# Create a vector named "new_order" containing the desired order to display individuals (smaller to taller)
new_order <- with(blueHeight, reorder(as.vector(blueHeight$SeedID), as.numeric(blueHeight$X5_w_height), median , na.rm=T))

# Draw boxplot
boxplot(as.numeric(blueHeight$X5_w_height) ~ new_order, names = paste(names(seedID), paste0("(n: ", as.vector(seedID), ")"), sep = "\n"), las=2, xlab = "", ylab = "Plantlet height (cm)", cex = .8)

#Add P1, P2
top <- which(names(seedID) %in% c("G2_b27_1", "G2_b7_1"))
text(x=top, y=1.8, c("P1", "P2"))
```

### R code {#boxgrowthcode}

```{r boxplotheightbluecode, echo=T, eval=F}
###~~~
#Subset to only include from blue rooting cluster
###~~~
blueHeight <- subset(subSurvHeigh, subSurvHeigh$Cluster == 'blue')

#Individual
seedID <- table(as.vector(blueHeight$SeedID))

# Create a vector named "new_order" containing the desired order to display individuals (smaller to taller)
new_order <- with(blueHeight, reorder(as.vector(blueHeight$SeedID), as.numeric(blueHeight$X5_w_height), median , na.rm=T))

###~~~
# Draw boxplot
###~~~
boxplot(as.numeric(blueHeight$X5_w_height) ~ new_order, names = paste(names(seedID), paste0("(n: ", as.vector(seedID), ")"), sep = "\n"), las=2, xlab = "", ylab = "Plantlet height (cm)", cex = .8)

#Add P1, P2
top <- which(names(seedID) %in% c("G2_b27_1", "G2_b7_1"))
text(x=top, y=1.8, c("P1", "P2"))
```

# References

<div id="refs"></div>

# Appendix 1 {.appendix}

Citations of all R packages used to generate this report. 

```{r generateBibliography, results="asis", echo=FALSE, warning = FALSE, message=FALSE}
library("knitcitations")
cleanbib()
options("citation_format" = "pandoc")
read.bibtex(file = "packages.bib")
``` 

# Appendix 2 {.appendix}

Version information about R, the operating system (OS) and attached or R loaded packages. This appendix was generated using `sessionInfo()`.

```{r eval=T, echo=F, warning = FALSE, message=FALSE}
sessionInfo()
```

# Appendix 3 {.appendix}

Tissue culture data at the basis of analyses presented in step 3.

```{r tidy, echo=F}
DT::datatable(MERGE, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
#knitr::kable(MERGE, caption = "Sampling at the basis of the sagebrush rooting experiment.")
```

# Appendix 4 {.appendix}

*In vitro* survival and growth data for plantlets at the basis of analyses presented in step 4.

```{r survgrowthappendix, echo=F}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

DT::datatable(survheig[,c(4,5,8,9,10,11)], extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
#knitr::kable(MERGE, caption = "Sampling at the basis of the sagebrush rooting experiment.")
```

