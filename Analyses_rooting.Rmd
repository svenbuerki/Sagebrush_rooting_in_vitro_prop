--- 
title: 'Development of an *in vitro* method of propagation using growth regulators for Basin Big sagebrush (*Artemisia tridentata* subsp. *tridentata*) to support genome sequencing and GxE research'
author: "Rachael Barron, Peggy Martinez, Marcelo Serpe, Sven Buerki"
output:
  bookdown::html_document2: 
    toc: TRUE
    toc_depth: 4
    toc_float: TRUE
link-citations: yes
fontsize: 12pt
bibliography: packages.bib
---

```{r packages, echo=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(rmarkdown)
library(bookdown)
#library(distill)
library(knitcitations)
library(formatR)
library(devtools)
library(gplots)
library(RColorBrewer)
library(grDevices)
library(pscl)
library(lmtest)
library(lsmeans)
library(emmeans)
library(DT)
library(chisq.posthoc.test)
library(ggpubr)
library(ggtree)
library(ape)
library(stringr)
library(ggridges)
library(ggplot2)
library(TreeTools)
library(forcats)
library(MASS)

#Generate BibTex citation file for all R packages used to produce report
knitr::write_bib(.packages(), file = 'packages.bib')
```


```{r setup, include=FALSE, cache=FALSE, message = FALSE}
#Load packages
library(knitr)
library(rmarkdown)
# Chunk options: see http://yihui.name/knitr/options/ ###

## Text results
opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE, include = TRUE)

## Code decoration
#opts_chunk$set(tidy = TRUE, R.options = list(width = 60), highlight = TRUE)

## Caching code
opts_chunk$set(cache = 2, cache.path = "cache/")

## Plots
#opts_chunk$set(fig.path = "Figures_MS/", dev=c('pdf', 'png'), dpi = 300)

## Locate figures as close as possible to requested position (=code)
#opts_chunk$set(fig.pos = "H")
```

# Reproducible workflow

## Integrating code, data, methods and key outcomes

This document is associated to Barron et al. and provides the reproducible workflow integrating data, code, methods and results associated to this study. 

Citations of `R` packages required to conduct this research and produce this document are provided in [Appendix 1]. Version information about `R`, the operating system (OS) and attached or `R` loaded packages are available in [Appendix 2]. The data underpinning this study are deposited on [GitHub](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop). Appendices together with the data and R code presented in this document should allow reproducibility of this study.

# Overview of methodology 

In this document, we are presenting the code associated to the analyses performed on tissue culture data (rooting and calli) generated from shoot tips of diploid *Artemisia tridentata* subsp. *tridentata* (2n=2x=18). 

The analyses were conducted in four steps:

- **Step 1:** Present, import and tidy data (see section \@ref(step1)).
- **Step 2:** Preliminary analyses on rooting experiment (see section \@ref(step2)).
- **Step 3:** Comparative analyses on rooting data (see section \@ref(step3)). This was done following a three-tier approach:
  + Prepare response variables.
  + Statistical analyses (*p*-value <= 0.01).
  + Clustering analyses.
- **Step 4:** *In vitro* survival and growth of plantlets (see section \@ref(step4)). 
  + Assessing the effect of growth regulators and rooting clusters on plantlet survival and growth rates.

# Step 1: Present, import and tidy data {#step1}

## Data presentation

The raw data used for this study are available in the [Sagebrush_rooting_in_vitro_prop](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop/tree/master/01_Raw_Data) GitHub repository in the `01_Raw_Data` folder. The data can be split into two categories supporting analyses presented in this study:

1. Tissue culture data: These data are related to the rooting experiment conducted on shoot tips.
2. *In vitro* survival and growth of plantlets: These data are related to the survival and growth experiment of rooted shoot tips into growth media.

We are providing more information on these data below.

### Coding of individual lines {#codingind}

Figure \@ref(fig:mother) allows to better grasp the coding approach applied to identify individual lines in this study. Our coding protocol is as follows:

- Genotype (`G1`: drought-tolerant or `G2`: drought-sensitive). `G1` was collected in Idaho, whereas `G2` came from Utah (see [Map](https://svenbuerki.github.io/Sagebrush_rooting_in_vitro_prop/location_pop.html) for more details.).
- Magenta box ID (`b`). Multiple seeds from the same mother plant/individual were sown per Magenta box.
- Individual in box. Because more than one plants were grown per magenta box, we have provided a unique ID for each plant.

For instance, `G2_b27_1` corresponds to an individual line representing the drought-sensitive genotype (`G2`) grown in the Magenta box #27 (`b27`) and it was the first sampled plant in this box (`1`).

Overall, the combination of these three items allows providing a unique ID to each individual line included in this study.

```{r mother, echo=F, eval=T, out.width="50%", fig.align='center', fig.cap= "Example of a Magenta box containing individuals of diploid sagebrush used for the rooting experiment."}
knitr::include_graphics("03_Figures_report/MotherPlant_low_res.jpg")
```

### Tissue culture data {.tabset .tabset-pills}

#### Import and tidy data

The objective of this section is to merge data on rooting and callus stored in spreadsheets (in `csv` format). Each spreadsheet corresponds to a block and the code provided in section \@ref(tidy) collates these data into one `data.frame` for downstream analyses. 

```{r tidy1, echo=FALSE, eval=TRUE}
###~~
#List all csv files (raw data from blocks)
###~~~

#Raw data are stored in the 01_Raw_Data folder
csv <- list.files(path = "01_Raw_Data", pattern='block.csv', full.names = T)

#Print names of csv files
print("List of csv files with block data:")
print(csv)

#Rm processed files
toRm <- grep("Processed_", csv)
if(length(toRm) > 0){
  csv <- csv[-toRm]
}

###~~~
#Execute loop to process all files and merge them (see below)
###~~~
# Empty object that will contain all processed data
# Save processed data into 02_Processed_data folder
MERGE <- NULL
for(i in 1:length(csv)){
  ###
  #Read in sv file
  mat <- read.csv(csv[i])
  
  ###~~~
  #Create final matrix
  ###~~~
  
  #List of individuals
  indcsv <- LETTERS[seq( from = 1, to = 9 )]
  
  #Empty matrix
  FINALmat <- data.frame(matrix(ncol=7, nrow = nrow(mat)*length(indcsv)))
  colnames(FINALmat) <- c("Block","Treatment", "Replicate", "Genotype", "Individual", "Callus", "Root")
  
  ###~~~
  #Start populating FINALmat 
  ###~~~
  # Add Block, Treatment and Replicates
  #Get data for block, treatment (and replicates)
  blockTreatRep <- rep(as.vector(mat$X), 9)
  FINALmat$Block <- sapply(strsplit(blockTreatRep, split='_'), "[", 1)
  FINALmat$Treatment <- paste(sapply(strsplit(blockTreatRep, split='_'), "[", 2), sapply(strsplit(blockTreatRep, split='_'), "[", 3), sep='_')
  FINALmat$Replicate <- sapply(strsplit(blockTreatRep, split='_'), "[", 4)
  
  #Deal with Controls
  contr <- grep("Control_", FINALmat$Treatment)
  FINALmat$Replicate[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",2)
  FINALmat$Treatment[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",1)
  
  ###~~~
  # Fetch individual data
  ###~~~
  
  #Where are ind in mat?
  indcol <- match(indcsv, colnames(mat))
  
  #Fetch raw data for each individual in block
  OUT <- NULL
  for(j in 1:length(indcol)){
    #Extract info for each individual
    tmp <- mat[,indcol[j]:(indcol[j]+2)]
    colnames(tmp) <- c("Ind", "Callus", "Root")
    OUT <- rbind(OUT, tmp)
  }
  
  ###~~~
  #Add OUT to FINALmat
  ###~~~
  
  #Genotypes
  FINALmat$Genotype <- sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 1)
  #Ind
  FINALmat$Individual <- paste(sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 2), sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 3), sep='_')
  #Callus
  FINALmat$Callus <- OUT$Callus
  #Root
  FINALmat$Root <- OUT$Root
  
  ###~~~
  #Save FINALmat
  ###~~~
  write.csv(FINALmat, file=paste0("02_Processed_data/Processed_", strsplit(csv[i], split="/")[[1]][2]), row.names = F, quote = F)
  
  ###~~~
  #MERGE all csv
  ###~~~
  MERGE <- rbind(MERGE, FINALmat)
}

###~~~
#Finalize preping of the data
###~~~
# Add a binary rooting col
MERGE <- data.frame(MERGE)

MERGE$IndGeno <- paste(MERGE$Genotype, MERGE$Individual, sep="_")

#Create a binary for Root
MERGE$RootBin <- MERGE$Root
MERGE$RootBin[MERGE$RootBin > 0] <- 1

###~~~
#Save MERGED files with all blocks
###~~~
# Save processed data into 02_Processed_data folder
write.csv(MERGE, file=paste0("02_Processed_data/Processed_", "blocks_rooting.csv"), row.names = F, quote = F)

#Return head of MERGE (see Appendix for more details)
print("Merge files and print head of data.frame:")
head(MERGE[,1:ncol(MERGE[-1])])
```

The final dataset (`MERGE`) contains the following columns (see Table \@ref(tab:statssampling) for more details on sampling):

- `Block`: 1 to 5. Each individual were randomly allocated to a block and a block has 9 individual.
- `Treatment`: `Control` (= no growth regulator), `IBA_1` (IBA 1 mg/l), `IBA_05` (IBA 0.5 mg/l), `NAA_1` (NAA 1 mg/l), `NAA_05` (NAA 0.5 mg/l).
- `Replicate`: 1 to 3. Each individual line had 3 shoot tips randomly allocated per treatment.
- `Genotype`: `G1` (drought-tolerant genotype from ID3 population) and `G2` (drought-sensitive population from UT2 population). See distribution [map](https://svenbuerki.github.io/Sagebrush_rooting_in_vitro_prop/location_pop.html).
- Individual line: `Individual` and `IndGeno`. The latter variable combines data on genotype and individual and it will be used throughout the document to represent the individual variable (see section \@ref(codingind) for more details).
- `Callus`: Binary (1 = present; 0 = absent).
- `Root`: Count of number of roots per shoot tip.

The `MERGE` dataset is available in [Appendix 3] and can be directly there. Individual and merged processed files are available in the `02_Processed_data` folder (see file `Processed_blocks_rooting.csv` for merged data or click [here](https://github.com/svenbuerki/Sagebrush_rooting_in_vitro_prop/blob/master/02_Processed_data/Processed_blocks_rooting.csv)).

#### R code {#tidy}

Raw data in `csv` format are stored in the `01_Raw_data` folder. The processed/tidy data are saved in `csv` format in the `02_Processed_data` folder. The `MERGE` object (in class `data.frame`) will be used for downstream analyses.

```{r tidy12, echo=T, eval=F}
###~~
#List all csv files (raw data from blocks)
###~~~

#Raw data are stored in the 01_Raw_Data folder
csv <- list.files(path = "01_Raw_Data", pattern='block.csv', full.names = T)

#Print names of csv files
print(csv)

#Rm processed files
toRm <- grep("Processed_", csv)
if(length(toRm) > 0){
  csv <- csv[-toRm]
}

###~~~
#Execute loop to process all files and merge them (see below)
###~~~
# Empty object that will contain all processed data
# Save processed data into 02_Processed_data folder
MERGE <- NULL
for(i in 1:length(csv)){
  ###
  #Read in sv file
  mat <- read.csv(csv[i])
  
  ###~~~
  #Create final matrix
  ###~~~
  
  #List of individuals
  indcsv <- LETTERS[seq( from = 1, to = 9 )]
  
  #Empty matrix
  FINALmat <- data.frame(matrix(ncol=7, nrow = nrow(mat)*length(indcsv)))
  colnames(FINALmat) <- c("Block","Treatment", "Replicate", "Genotype", "Individual", "Callus", "Root")
  
  ###~~~
  #Start populating FINALmat 
  ###~~~
  # Add Block, Treatment and Replicates
  #Get data for block, treatment (and replicates)
  blockTreatRep <- rep(as.vector(mat$X), 9)
  FINALmat$Block <- sapply(strsplit(blockTreatRep, split='_'), "[", 1)
  FINALmat$Treatment <- paste(sapply(strsplit(blockTreatRep, split='_'), "[", 2), sapply(strsplit(blockTreatRep, split='_'), "[", 3), sep='_')
  FINALmat$Replicate <- sapply(strsplit(blockTreatRep, split='_'), "[", 4)
  
  #Deal with Controls
  contr <- grep("Control_", FINALmat$Treatment)
  FINALmat$Replicate[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",2)
  FINALmat$Treatment[contr] <- sapply(strsplit(FINALmat$Treatment[contr], split="_"), "[",1)
  
  ###~~~
  # Fetch individual data
  ###~~~
  
  #Where are ind in mat?
  indcol <- match(indcsv, colnames(mat))
  
  #Fetch raw data for each individual in block
  OUT <- NULL
  for(j in 1:length(indcol)){
    #Extract info for each individual
    tmp <- mat[,indcol[j]:(indcol[j]+2)]
    colnames(tmp) <- c("Ind", "Callus", "Root")
    OUT <- rbind(OUT, tmp)
  }
  
  ###~~~
  #Add OUT to FINALmat
  ###~~~
  
  #Genotypes
  FINALmat$Genotype <- sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 1)
  #Ind
  FINALmat$Individual <- paste(sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 2), sapply(strsplit(as.vector(OUT$Ind), split='_'), "[", 3), sep='_')
  #Callus
  FINALmat$Callus <- OUT$Callus
  #Root
  FINALmat$Root <- OUT$Root
  
  ###~~~
  #Save FINALmat
  ###~~~
  write.csv(FINALmat, file=paste0("02_Processed_data/Processed_", strsplit(csv[i], split="/")[[1]][2]), row.names = F, quote = F)
  
  ###~~~
  #MERGE all csv
  ###~~~
  MERGE <- rbind(MERGE, FINALmat)
}

###~~~
#Finalize preping of the data
###~~~
# Add a binary rooting col
MERGE <- data.frame(MERGE)

MERGE$IndGeno <- paste(MERGE$Genotype, MERGE$Individual, sep="_")

#Create a binary for Root
MERGE$RootBin <- MERGE$Root
MERGE$RootBin[MERGE$RootBin > 0] <- 1

###~~~
#Save MERGED files with all blocks
###~~~
# Save processed data into 02_Processed_data folder
write.csv(MERGE, file=paste0("02_Processed_data/Processed_", "blocks_rooting.csv"), row.names = F, quote = F)

#Return head of MERGE (see Appendix for more details)
head(MERGE)
```

### *In vitro* survival and growth of plantlets {.tabset .tabset-pills}

Data on survival and plantlets heights at 3 and 5 weeks are stored in the `01_Raw_Data` folder in `Survival_height_clones.csv`. The dataset is available in [Appendix 4] and can be directly downloaded there. Please find below the description of the variables:

- `SeedID`: This is equal to `IndGeno` in `MERGE` and therefore refers to the rooted shoot tip that was transferred.
- `Cluster`: Rooting cluster as inferred by the clustering analysis.
- `X3_w_survival` and `X5_w_survival`: Binary survival (1 = alive, 0 = dead) data at 3 and 5 weeks.
- `X3_w_height` and `X5_w_height`: Continuous plantlets heights data (in cm) at 3 and 5 weeks.

# Step 2: Preliminary analyses on rooting experiment {#step2}

Preliminary data summarizing results of our experiments are provided here to assess the effect of growth regulators on *in vitro* rooting of *Artemisia tridentata*. During the course of the experiment, calli developed on a large proportion of shoot tips, which was unexpected based on preliminary data. We are therefore summarizing these data here by treatment and will devote a portion of the analyses to investigate whether callus development was associated to treatments and whether those inhibited or promoted rooting.

## Statistics on plant materials {.tabset .tabset-pills}

### Analyses

Table \@ref(tab:statssampling) provides a summary of plant materials included in this study. Overall, 45 individuals distributed into two genotypes (which were evenly sampled) were generated from seeds. For each individual line, 15 shoot tips were produced and included into five treatments with three replicates (= 3 shoot tips/ind./treatment). Individuals were randomly allocated to 5 blocks containing 9 individual each. 

Overall, the sampling at the basis of the rooting experiment could summarized as follows:

> "45 individual lines x 5 treatments x 3 replicates, for n = 675 total shoot tips."

The code below generates Table \@ref(tab:statssampling). The R code associated to producing Table \@ref(tab:statssampling) is available in section \@ref(statsampl). 

```{r statssampling, echo=FALSE, eval=TRUE}
#Create and populate table to summarize sampling (Table 1)
samp_mat <- matrix(ncol=9, nrow=1)
colnames(samp_mat) <- c("N. block", "N. treatments", "Treatments", "N. replicates", "N. genotypes", 
                        "N. individuals", "N. ind. per genotype", "Ind. G1", "Ind. G2")

#N block
samp_mat[,1] <- length(unique(MERGE$Block))
#N treat
samp_mat[,2] <- length(unique(MERGE$Treatment))
#Treat ID
samp_mat[,3] <- paste(sort(unique(MERGE$Treatment)), collapse = ", ")
#N replicates
samp_mat[,4] <- length(unique(MERGE$Replicate))
#N genotypes
samp_mat[,5] <- length(unique(MERGE$Genotype))
#N ind
samp_mat[,6] <- length(unique(MERGE$IndGeno))
#N ind per genotype
samp_mat[,7] <- paste(paste("G1:", list(table(MERGE$Genotype)/15)[[1]][1]), paste("G2:", list(table(MERGE$Genotype)/15)[[1]][2]), sep=', ')
#List ind G1
samp_mat[,8] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G1"))), collapse=', ')
#List ind G2
samp_mat[,9] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G2"))), collapse=', ')

#Write table
#write.csv(samp_mat, file="Table_1_sampling_summary.csv", row.names = F)

#Plot table
knitr::kable(samp_mat, caption = "Summary of sampling at the basis of sagebrush rooting experiment.")
```

### R code {#statsampl}

```{r statssampling2, echo=TRUE, eval=FALSE}
#Create and populate table to summarize sampling (Table 1)
samp_mat <- matrix(ncol=9, nrow=1)
colnames(samp_mat) <- c("N. block", "N. treatments", "Treatments", "N. replicates", "N. genotypes", 
                        "N. individuals", "N. ind. per genotype", "Ind. G1", "Ind. G2")

#N block
samp_mat[,1] <- length(unique(MERGE$Block))
#N treat
samp_mat[,2] <- length(unique(MERGE$Treatment))
#Treat ID
samp_mat[,3] <- paste(sort(unique(MERGE$Treatment)), collapse = ", ")
#N replicates
samp_mat[,4] <- length(unique(MERGE$Replicate))
#N genotypes
samp_mat[,5] <- length(unique(MERGE$Genotype))
#N ind
samp_mat[,6] <- length(unique(MERGE$IndGeno))
#N ind per genotype
samp_mat[,7] <- paste(paste("G1:", list(table(MERGE$Genotype)/15)[[1]][1]), paste("G2:", list(table(MERGE$Genotype)/15)[[1]][2]), sep=', ')
#List ind G1
samp_mat[,8] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G1"))), collapse=', ')
#List ind G2
samp_mat[,9] <- paste(sort(unique(subset(MERGE$IndGeno, MERGE$Genotype == "G2"))), collapse=', ')

#Write table
#write.csv(samp_mat, file="Table_1_sampling_summary.csv", row.names = F)

#Plot table
knitr::kable(samp_mat, caption = "Summary of sampling at the basis of sagebrush rooting experiment.")
```


## Effect of growth regulators on *in vitro* callus development in *Artemisia tridentata* {.tabset .tabset-pills}

### Analyses

The effect of growth regulators on callus development is provided in Table \@ref(tab:growthbyregulatorcallus) and compared to the control treatment (= no growth regulator). These data show contrasting calli development between the control and treatments including growth hormones. Control shoot tips had limited calli development, whereas responses for those undergoing treatments were very high (>70%; Table \@ref(tab:growthbyregulatorcallus)). The R code associated to these analyses is presented in section \@ref(growthbyregulatorcallus).

```{r growthbyregulatorcallus, echo=F, eval=T}
#Matrix summarizing effect of growth regulators on rooting
CallusStatbyTreat <- matrix(ncol=3, nrow=5)
colnames(CallusStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)")
rownames(CallusStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
CallusStatbyTreat <- as.data.frame(CallusStatbyTreat)

#Populate matrix
CallusStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(CallusStatbyTreat), split="_"),"[[",1)
CallusStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(CallusStatbyTreat)[2:nrow(CallusStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(CallusStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(CallusStatbyTreat)[i])
  CallusStatbyTreat$`Response (%)`[i] <- round(100*mean(foo$Callus),2)
}

#Plot table
knitr::kable(CallusStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro calli development on shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates.")
```

### R code {#growthbyregulatorcallus}

```{r growthbyregulatorcalluscode, echo=T, eval=F}
#Matrix summarizing effect of growth regulators on rooting
CallusStatbyTreat <- matrix(ncol=3, nrow=5)
colnames(CallusStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)")
rownames(CallusStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
CallusStatbyTreat <- as.data.frame(CallusStatbyTreat)

#Populate matrix
CallusStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(CallusStatbyTreat), split="_"),"[[",1)
CallusStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(CallusStatbyTreat)[2:nrow(CallusStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(CallusStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(CallusStatbyTreat)[i])
  CallusStatbyTreat$`Response (%)`[i] <- round(100*mean(foo$Callus),2) 
}


#Plot table
knitr::kable(CallusStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro calli development on shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates.")
```

## Effect of growth regulators on *in vitro* rooting of *Artemisia tridentata* {.tabset .tabset-pills}

### Analyses

The effect of growth regulators is provided in Table \@ref(tab:growthbyregulator) and compared to the control treatment (= no growth regulator). These data show a very high level of variation in rooting (see column `Av. No. roots`). We are hypothesizing that this trend is caused by an individual effect. To test this hypothesis we will conduct comparative analyses (see **Step 4**) to sort individuals based on their rooting abilities. Finally, the effect of growth regulators on *in vitro* rooting will be compared within each cluster. The R code associated to these analyses is presented in section \@ref(growthbyregulatorcode).

```{r growthbyregulator, echo=F, eval=T}
#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreat <- matrix(ncol=4, nrow=5)
colnames(RootingStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots")
rownames(RootingStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
RootingStatbyTreat <- as.data.frame(RootingStatbyTreat)

#Populate matrix
RootingStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(RootingStatbyTreat), split="_"),"[[",1)
RootingStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(RootingStatbyTreat)[2:nrow(RootingStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(RootingStatbyTreat)[i])
  RootingStatbyTreat$`Response (%)`[i] <- round(100*(mean(foo$RootBin)),2)
  RootingStatbyTreat$`Av. No. of roots`[i] <- round(mean(foo$Root),2)
}


#Plot table
knitr::kable(RootingStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro rooting for shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates; Av. No. of roots (Average number of roots per shoot tip): means.")
```

### R code {#growthbyregulatorcode}

```{r growthbyregulatorcode, echo=T, eval=F}
#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreat <- matrix(ncol=4, nrow=5)
colnames(RootingStatbyTreat) <- c("Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots")
rownames(RootingStatbyTreat) <- sort(unique(MERGE$Treatment))

#Convert to dataframe
RootingStatbyTreat <- as.data.frame(RootingStatbyTreat)

#Populate matrix
RootingStatbyTreat$`Growth regulator` <- sapply(strsplit(rownames(RootingStatbyTreat), split="_"),"[[",1)
RootingStatbyTreat$`Concentration (mg/l)` <- c("-", sapply(strsplit(rownames(RootingStatbyTreat)[2:nrow(RootingStatbyTreat)], split="_"),"[[",2))

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreat)){
  foo <- subset(MERGE, MERGE$Treatment == rownames(RootingStatbyTreat)[i])
  RootingStatbyTreat$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep=" ")
  RootingStatbyTreat$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreat, row.names=F, caption = "Effect of growth regulators on in vitro rooting for shoot tips of diploid Artemisia tridentata subsp. tridentata. Response: mean of the three replicates +/- standard deviation; Av. No. of roots (Average number of roots per shoot tip): mean +/- standard deviation.")
```

# Step 3: Comparative analyses {#step3}

The input data for these analyses are stored in `MERGE`, but we will transform the data to test for treatment, genotype and individual effects. 

## Prepare the response variables

### Treatment {.tabset .tabset-pills}

The effect of growth regulators (= treatment) will be assessed based on three response variables: the number of shoot tips per plate that formed callus, those that developed roots (presence/absence), and the total number of roots. The analyses and associated R code (see section \@ref(codeTreatdata)) to produce these variables based on `MERGE` is found below. 

#### Analyses

We are displaying callus and rooting responses by plate unit to test for treatment effect. Here, a plate corresponds to an experimental unit, which is equal to a treatment by block by replicate (basically each row in the table is a plate). In a nutshell, the R code subset `MERGE` by plate and counts the number of callus (binary), root (binary) and root (count) (see section \@ref(codeTreatdata) for more details).    

```{r prepTreat, echo=F, eval=T, }
#Prepare an empty matrix to be populated 

#How many rows? 5 treatments * 5 blocks * 3 replicates
NrowTreat <- length(unique(MERGE$Treatment))*length(unique(MERGE$Block))*length(unique(MERGE$Replicate))

#Create empty matrix
TreatMat <- matrix(ncol=6, nrow = NrowTreat)
colnames(TreatMat) <- c("Treatment", "Block", "Replicate","Callus","RootBin","RootCount")

#Add treatment, block and replicate
TreatMat[,1] <- sort(rep(unique(MERGE$Treatment), length(unique(MERGE$Block))*length(unique(MERGE$Replicate))))
TreatMat[,2] <- sort(rep(unique(MERGE$Block), length(unique(MERGE$Replicate))))
TreatMat[,3] <- rep(seq(from=1, to = length(unique(MERGE$Replicate)), by = 1), nrow(TreatMat)/3)

#TreatMat <- as.data.frame(TreatMat)

#Get Callus Bin, Root Bin and Root Cout
for(i in 1:nrow(TreatMat)){
  tmp <- subset(MERGE, MERGE$Treatment == TreatMat[i,1] & MERGE$Block == TreatMat[i,2] & MERGE$Replicate == TreatMat[i,3])
  #Callus Binary
  TreatMat[i,4] <- sum(as.numeric(tmp$Callus))
  #Root Binary
  TreatMat[i,5] <- sum(as.numeric(tmp$RootBin))
  #Root Count
  TreatMat[i,6] <- sum(as.numeric(tmp$Root))
}
#Convert into data.frame
TreatMat <- as.data.frame(TreatMat)

#Change class of response variables to numerical
i <- c(4, 5, 6) 
TreatMat[ , i] <- apply(TreatMat[ , i], 2, function(x) as.numeric(as.character(x)))

#Plot table
DT::datatable(TreatMat, caption = "Data for treatment analyses sorted by plates.")
```

#### R code {#codeTreatdata}

```{r prepTreatCode, echo=F, eval=T, }
#Prepare an empty matrix to be populated 

#How many rows? 5 treatments * 5 blocks * 3 replicates
NrowTreat <- length(unique(MERGE$Treatment))*length(unique(MERGE$Block))*length(unique(MERGE$Replicate))

#Create empty matrix
TreatMat <- matrix(ncol=6, nrow = NrowTreat)
colnames(TreatMat) <- c("Treatment", "Block", "Replicate","Callus","RootBin","RootCount")

#Add treatment, block and replicate
TreatMat[,1] <- sort(rep(unique(MERGE$Treatment), length(unique(MERGE$Block))*length(unique(MERGE$Replicate))))
TreatMat[,2] <- sort(rep(unique(MERGE$Block), length(unique(MERGE$Replicate))))
TreatMat[,3] <- rep(seq(from=1, to = length(unique(MERGE$Replicate)), by = 1), nrow(TreatMat)/3)

#TreatMat <- as.data.frame(TreatMat)

#Get Callus Bin, Root Bin and Root Cout
for(i in 1:nrow(TreatMat)){
  tmp <- subset(MERGE, MERGE$Treatment == TreatMat[i,1] & MERGE$Block == TreatMat[i,2] & MERGE$Replicate == TreatMat[i,3])
  #Callus Binary
  TreatMat[i,4] <- sum(as.numeric(tmp$Callus))
  #Root Binary
  TreatMat[i,5] <- sum(as.numeric(tmp$RootBin))
  #Root Count
  TreatMat[i,6] <- sum(as.numeric(tmp$Root))
}
#Convert into data.frame
TreatMat <- as.data.frame(TreatMat)

#Change class of response variables to numerical
i <- c(4, 5, 6) 
TreatMat[ , i] <- apply(TreatMat[ , i], 2, function(x) as.numeric(as.character(x)))

#Plot table
DT::datatable(TreatMat, caption = "Data for treatment analyses sorted by plates.")
```

### Genotype {.tabset .tabset-pills}

The effect of genotypes will be assessed based on three response variables: the number of shoot tips per plate that formed callus, those that developed roots (presence/absence), and the total number of roots. The analyses and associated R code (see section \@ref(codeGenodata)) to produce these variables based on `MERGE` is found below.

#### Analyses

We are displaying callus and rooting responses by individual to test for treatment effect. See section \@ref(codeGenodata) for more details on R code.

```{r PrepGeno, echo=F, eval=T}
#Prepare an empty matrix to be populated 

#How many rows? This is equal to number of individual lines
NrowGen <- length(unique(MERGE$IndGeno))

#Create empty matrix
TreatGeno <- matrix(ncol=5, nrow = NrowGen)
colnames(TreatGeno) <- c("Genotype", "IndGeno", "Callus","RootBin","RootCount")

#Populate with Genotype, Individual
TreatGeno[,2] <- unique(MERGE$IndGeno)
TreatGeno[,1] <- sapply(strsplit(unique(MERGE$IndGeno), split="_"), "[[", 1)

#Get Callus Bina, Root Bin and Root Cout
for(i in 1:nrow(TreatGeno)){
  tmp <- subset(MERGE, MERGE$Genotype == TreatGeno[i,1] & MERGE$IndGeno == TreatGeno[i,2])
  #Callus Binary
  TreatGeno[i,3] <- sum(as.numeric(tmp$Callus))
  #Root Binary
  TreatGeno[i,4] <- sum(as.numeric(tmp$RootBin))
  #Root Count
  TreatGeno[i,5] <- sum(as.numeric(tmp$Root))
}
#Convert into data.frame
TreatGeno <- as.data.frame(TreatGeno)

#Order by genotype
TreatGeno <- TreatGeno[order(TreatGeno$Genotype),]

#Change class of response variables to numerical
i <- c(3, 4, 5) 
TreatGeno[ , i] <- apply(TreatGeno[ , i], 2, function(x) as.numeric(as.character(x)))

#Plot table
DT::datatable(TreatGeno, caption = "Data for genotype analyses sorted by individuals.")
```

#### R code {#codeGenodata}

```{r PrepGenoCode, echo=T, eval=F}
#Prepare an empty matrix to be populated 

#How many rows? This is equal to number of individual lines
NrowGen <- length(unique(MERGE$IndGeno))

#Create empty matrix
TreatGeno <- matrix(ncol=5, nrow = NrowGen)
colnames(TreatGeno) <- c("Genotype", "IndGeno", "Callus","RootBin","RootCount")

#Populate with Genotype, Individual
TreatGeno[,2] <- unique(MERGE$IndGeno)
TreatGeno[,1] <- sapply(strsplit(unique(MERGE$IndGeno), split="_"), "[[", 1)

#Get Callus Bina, Root Bin and Root Cout
for(i in 1:nrow(TreatGeno)){
  tmp <- subset(MERGE, MERGE$Genotype == TreatGeno[i,1] & MERGE$IndGeno == TreatGeno[i,2])
  #Callus Binary
  TreatGeno[i,3] <- sum(as.numeric(tmp$Callus))
  #Root Binary
  TreatGeno[i,4] <- sum(as.numeric(tmp$RootBin))
  #Root Count
  TreatGeno[i,5] <- sum(as.numeric(tmp$Root))
}
#Convert into data.frame
TreatGeno <- as.data.frame(TreatGeno)

#Order by genotype
TreatGeno <- TreatGeno[order(TreatGeno$Genotype),]

#Change class of response variables to numerical
i <- c(3, 4, 5) 
TreatGeno[ , i] <- apply(TreatGeno[ , i], 2, function(x) as.numeric(as.character(x)))

#Plot table
DT::datatable(TreatGeno, caption = "Data for genotype analyses sorted by individuals.")
```

### Individual {.tabset .tabset-pills}

#### Analyses

Here, we are preparing contingency tables for callus (binary) and root (binary) data to test for individual effect. Analyses on root (count) data will be directly performed on the `MERGE` dataset. See section \@ref(codeInddata) for associated R code.

```{r IndCallBin, echo=F, eval=T}
###~~~
#Callus
###~~~
#Binary for each individual line
IndCallBin <- table(MERGE$IndGeno, MERGE$Callus)

#Plot table
DT::datatable(as.data.frame.matrix(IndCallBin), caption = "Callus data for individual analyses (0 = absence; 1 = presence).")
```

```{r IndRootBin, echo=F, eval=T}
###~~~
#Root
###~~~
#Binary for each individual line
IndRootBin <- table(MERGE$IndGeno, MERGE$RootBin)

#Plot table
DT::datatable(as.data.frame.matrix(IndRootBin), caption = "Root data for individual analyses (0 = absence; 1 = presence).")
```

#### R code {#codeInddata}

```{r IndCallRtBincode, echo=T, eval=F}
###~~~
#Callus
###~~~
#Binary for each individual line
IndCallBin <- table(MERGE$IndGeno, MERGE$Callus)

#Plot table
DT::datatable(as.data.frame.matrix(IndCallBin), caption = "Callus data for individual analyses (0 = absence; 1 = presence).")

###~~~
#Root
###~~~
#Binary for each individual line
IndRootBin <- table(MERGE$IndGeno, MERGE$RootBin)

#Plot table
DT::datatable(as.data.frame.matrix(IndRootBin), caption = "Root data for individual analyses (0 = absence; 1 = presence).")
```

## Testing for treatment effect

The effect of growth regulators (= treatments) is assessed on three response variables stored in `TreatMat`: the number of shoot tips per plate that formed callus (`Callus`), those that developed roots (presence/absence; `RootBin`), and the total number of roots (`RootCount`). The latter served as a proxy for the number of roots per shoot tip. The presence/absence of callus and roots was evaluated using a generalized linear model (GLM) with Poisson distributed errors. The goodness of fit of the model was verified with a chi-square test. The treatments' impact on the total number of roots was analyzed using a negative binomial generalized linear model (GLMNB). The deviance goodness of fit test ascertained models' fitness, as judged by *p*-values above 0.05. Post-hoc multiple comparisons were analyzed with Tukey's significant difference test. The GLM, GLMNB, and post-hoc analyses were conducted in R using the *glm*, *glm.nb*, and *emmeans* functions, respectively.

### Callus

#### GLM model

```{r callusGLMbin, echo=T, eval=T}
###~~~
#GLM poisson model on Callus data
###~~~
m1 <- glm(Callus ~ Treatment, family = poisson(link = "log"), data=TreatMat)
summary (m1)

###~~~
#Test for goodness of fit of deviance
###~~~
pchisq(m1$deviance, m1$df.residual, lower.tail = FALSE)
```

#### Post-hoc: Tukey's significant difference test

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansCalBin, eval=T, echo=T, warning=F}
# Estimated marginal means (Least-squares means) for treatments using m1
posthocCallus <- emmeans(m1, specs = pairwise ~ Treatment, type = "response")

# Identify significant pairwise comparisons
signCalTreat <- as.data.frame(posthocCallus$contrasts)
signCalTreat <- signCalTreat[which(signCalTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signCalTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons based on callus binary data.")
```

Table \@ref(tab:emmeansCalBin) summarizes statistical comparisons of treatments focusing on significant effects. These analyses are not entirely conclusive, but they demonstrate that:

- (a) Control is significantly different than the other treatments (`***`). Here, very limited calli production was observed in shoot tips included in the control treatment.
- (b) No significant differences between IBA_1, IBA_05, NAA_01 and NAA_05.

### Root

Here, we will analyze treatment effect on rooting using the binary (`RootBin`) and count (`Root`) data.

#### Binary data

##### GLM model

```{r rootGLMbin, echo=T, eval=T}
###~~~
#GLM poisson model on Root binary data
###~~~
m1root <- glm(RootBin ~ TreatMat$Treatment, family = poisson(link = "log"), data=TreatMat)
summary (m1root)

###~~~
#Test for goodness of fit of deviance
###~~~
pchisq(m1root$deviance, m1root$df.residual, lower.tail = FALSE)
```

##### Post-hoc: Tukey's significant difference test

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansRootBin, eval=T, echo=T, warning=F}
# Estimated marginal means (Least-squares means) for treatments using m1root
posthocRootBin <- emmeans(m1root, specs = pairwise ~ Treatment, type = "response")

# Identify significant pairwise comparisons
signRtTreat <- as.data.frame(posthocRootBin$contrasts)
signRtTreat <- signRtTreat[which(signRtTreat$p.value <= 0.01),c(1:3,5,6)]

#Print table
knitr::kable(signRtTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons based on root binary data.")
```

Table \@ref(tab:emmeansRootBin) summarizes statistical comparison of treatments focusing on significant effects. These analyses are not entirely conclusive, but they demonstrate that:

- (a) Control is significantly different than the other treatments (`***`).
- (b) No significant differences between IBA_1, IBA_05, NAA_01 and NAA_05. 

#### Count data

##### GLM negative binomial model

The *glm.nb* function is implemented in the `MASS` R package. 

```{r rootGLMcount, echo=T, eval=T}
###~~~
#GLM negative binomial poisson model on Root count data
###~~~
m2root <- glm.nb(RootCount ~ Treatment, data= TreatMat)
summary (m2root)

m3root <- glm.nb(RootCount ~ Treatment + Block, data= TreatMat)
summary (m3root)

###~~~
#Test for goodness of fit of deviance
###~~~
print("M3 better fits data compared to M2. M3 will be used for Tukey's tests.")
#M2
pchisq(m2root$deviance, m2root$df.residual, lower.tail = FALSE)
#M3
pchisq(m3root$deviance, m2root$df.residual, lower.tail = FALSE)
```

##### Post-hoc: Tukey's significant difference test

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansRootcount, eval=T, echo=T, warning=F}
# Estimated marginal means (Least-squares means) for treatments using m2root
posthocRootCout <- emmeans(m3root, specs = pairwise ~ Treatment, type = "response")

# Identify significant pairwise comparisons
signRtCtTreat <- as.data.frame(posthocRootCout$contrasts)
signRtCtTreat <- signRtCtTreat[which(round(signRtCtTreat$p.value,3) <= 0.015),c(1:3,5,6)]

#Print table
knitr::kable(signRtCtTreat, row.names=F, caption = "Significant (p-value <= 0.01) treatment pairwise comparisons based on root count data.")
```

Table \@ref(tab:emmeansRootcount) summarizes statistical comparison of treatments focusing on significant effects. The ranking of treatments is as follows:

- (a): `IBA1`
- (ab): `IBA_05`
- (b): `NAA_1` and `NAA_05`
- (c): `Control`

## Testing for genotype effect

The effect of genotypes is assessed on three response variables stored in `TreatGeno`: the number of shoot tips per plate that formed callus (`Callus`), those that developed roots (presence/absence; `RootBin`), and the total number of roots (`RootCount`). The latter served as a proxy for the number of roots per shoot tip. The presence/absence of callus and roots was evaluated using a generalized linear model (GLM) with Poisson distributed errors. The goodness of fit of the model was verified with a chi-square test. The treatments' impact on the total number of roots was analyzed using a negative binomial generalized linear model (GLMNB). The deviance goodness of fit test ascertained models' fitness, as judged by *p*-values above 0.05. Post-hoc multiple comparisons were analyzed with Tukey's significant difference test. The GLM, GLMNB, and post-hoc analyses were conducted in R using the *glm*, *glm.nb*, and *emmeans* functions, respectively.

### Callus

#### GLM model

```{r callusGLMbinGen, echo=T, eval=T}
###~~~
#GLM poisson model on Callus data
###~~~
m1CalGeno <- glm(Callus ~ Genotype, family = poisson(link = "log"), data=TreatGeno)
summary (m1CalGeno)

###~~~
#Test for goodness of fit of deviance
###~~~
pchisq(m1CalGeno$deviance, m1CalGeno$df.residual, lower.tail = FALSE)
```

#### Post-hoc: Tukey's significant difference test

The *emmeans* function implemented in the `emmeans` R package [@R-emmeans] was used to compare treatments (with a *p*-value <= 0.01):

```{r emmeansCalBinGeno, eval=T, echo=T, warning=F}
# Estimated marginal means (Least-squares means) for treatments using m1CalGeno
posthocCallusGeno <- emmeans(m1CalGeno, specs = pairwise ~ Genotype, type = "response")

# Identify significant pairwise comparisons
signCalGeno <- as.data.frame(posthocCallusGeno$contrasts)
signCalGeno <- signCalGeno[which(signCalGeno$p.value <= 0.01),c(1:3,5,6)]

#Print table
print("No significant difference between genotypes!")
```

### Root

Here, we will analyze treatment effect on rooting using the binary (`RootBin`) and count (`Root`) data. Both variables will be analyzed with the negative binomial model implemented in *glm.nb* function.

#### Binary data

##### GLM negative binomial model

```{r rootGLMbinGeno, echo=T, eval=T}
###~~~
#GLM negative binomial poisson model on Root binary data
###~~~
m1root <- glm.nb(RootBin ~ Genotype, data= TreatGeno)
summary (m1root)

#Print table
print(paste("No significant difference between genotypes!", "No need to pursue analyses", sep="\n"))

###~~~
#Test for goodness of fit of deviance
###~~~
pchisq(m1root$deviance, m1root$df.residual, lower.tail = FALSE)
```

#### Count data

##### GLM negative binomial model

```{r rootGLMCtGeno, echo=T, eval=T}
###~~~
#GLM negative binomial poisson model on Root count data
###~~~
m2root <- glm.nb(RootCount ~ Genotype, data= TreatGeno)
summary(m2root)

#Print table
print(paste("No significant difference between genotypes!", "No need to pursue analyses", sep="\n"))

###~~~
#Test for goodness of fit of deviance
###~~~
pchisq(m2root$deviance, m2root$df.residual, lower.tail = FALSE)
```

## Testing for individual effect

Here, we will start by testing for individual effects by conducting chi-square analyses on binary callus and root data stored respectively in `IndCallBin` and `IndRootBin`. These analyses will be further investigated by conducting clustering analyses (see section \@ref(clustAnalyses)). 

To identify top performers, we will then apply the Kruskal-Wallis rank sum test on root count data followed by pairwise Wilcox tests based on the `MERGE` dataset. We use a non-parametric test since the data are not normaly distributed:

```{r norm, echo=T, eval=T}
# Shapiro-Wilk normality test on Root count data in MERGE
shapiro.test(MERGE$Root)
```

To qualify as a top performer, an individual will have to outperform >= 20% of individuals (based on pairwise Wilcox tests with a *p*-value <= 0.01).

### Callus and Root binary data

```{r}
###~~~
#Callus binary data
###~~~
chisq.test(t(IndCallBin))

###~~~
#Root binary data
###~~~
chisq.test(t(IndRootBin))
```

Both analyses strongly suggest individual effects, which will be further investigated in the clustering analyses (see section \@ref(clustAnalyses)). 

### Root count data {.tabset .tabset-pills}

#### Analyses

Here, we are applying the Kruskal-Wallis rank sum test followed by pairwise Wilcox tests to assess individual effects and rank those (with a *p*-value of <= 0.01) on `MERGE` data. Results of these analyses are presented below and the R code is available in section \@ref(RInd). To qualify as a top performer, an individual has to outperform >= 20% of individuals (based on pairwise Wilcox tests with a *p*-value <= 0.01).

```{r kruskalInd, echo=F, eval=T, message=FALSE, warning=FALSE}
###~~~
# Run Kruskal-Wallis Rank Sum Test
###~~~

print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Individual")
K1 <- kruskal.test(Root ~ IndGeno, data = MERGE)
print(K1)

###~~~
# Run Wilcox test on Root ~ IndGeno
###~~~

print("Perform Wilcox test on Root ~ Individual")
wilcoxRootInd <- pairwise.wilcox.test(MERGE$Root, MERGE$IndGeno,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootInd <- wilcoxRootInd$p.value

# Convert distance matrix into 3 cols: ind1, ind2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootInd)){
  tmp <- wilcoxRootInd[i,]
  tmp <- cbind(rep(rownames(wilcoxRootInd)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Ind1", "Ind2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Individual effect
IndRoot <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per individual
meanRoot <- aggregate(Root ~ IndGeno, mean, data = MERGE)

# Diff of means Ind1-Ind2
IndRoot$Diff_mean <- meanRoot[match(IndRoot[,1], meanRoot[,1]),2]-meanRoot[match(IndRoot[,2], meanRoot[,1]),2]

# What are the top performers (= most efficient at producing roots)?
IndRootOut <- IndRoot[which(IndRoot$Diff_mean > 0),]

# Percentage of individuals that are outperformed by P1
TopInd <- 100*(sort(table(IndRootOut[,1]), decreasing=T)/length(unique(MERGE$IndGeno)))

# Select only ind that are outperforming at least 20% of individuals 
TopInd <- TopInd[which(TopInd >= 20)]

TopInd <- as.matrix(round(TopInd, 1))
colnames(TopInd) <- c("Percentage of individuals outperformed")

# Plot table
knitr::kable(TopInd, caption = "List of individual that are outperforming at least 20% of individuals (based on Wilcoxon rank sum tests on Individual variable with a pval <= 0.01).")
```

The analyses reported in Table \@ref(tab:kruskalInd) demonstrate that only two individuals (`r rownames(TopInd)`, which are referred to as P1 and P2) are significantly outperforming at least 20% of the individuals based on their rooting abilities independently to treatment.

#### R code {#RInd}

```{r kruskalIndcode, echo=T, eval=F, message=FALSE, warning=FALSE}
###~~~
# Run Kruskal-Wallis Rank Sum Test
###~~~

print("Perform Kruskal-Wallis Rank Sum Test: Root ~ Individual")
K1 <- kruskal.test(Root ~ IndGeno, data = MERGE)
print(K1)

###~~~
# Run Wilcox test on Root ~ IndGeno
###~~~

print("Perform Wilcox test on Root ~ Individual")
wilcoxRootInd <- pairwise.wilcox.test(MERGE$Root, MERGE$IndGeno,
                 p.adjust.method = "BH")

# Only select data.frame (distance matrix)
wilcoxRootInd <- wilcoxRootInd$p.value

# Convert distance matrix into 3 cols: ind1, ind2, p-val
OUT <- NULL
for(i in 1:nrow(wilcoxRootInd)){
  tmp <- wilcoxRootInd[i,]
  tmp <- cbind(rep(rownames(wilcoxRootInd)[i], length(tmp)), names(tmp), as.vector(tmp))
  OUT <- rbind(OUT, tmp)
}
wilcoxSimp <- as.data.frame(OUT)
colnames(wilcoxSimp) <- c("Ind1", "Ind2", "P-val")

# Tidy data
wilcoxSimp <- as.matrix(wilcoxSimp[-which(is.na(wilcoxSimp$`P-val`) == T),])

# Individual effect
IndRoot <- as.data.frame(wilcoxSimp[which(as.numeric(wilcoxSimp[,3]) <= 0.01),])

# Infer mean rooting per individual
meanRoot <- aggregate(Root ~ IndGeno, mean, data = MERGE)

# Diff of means Ind1-Ind2
IndRoot$Diff_mean <- meanRoot[match(IndRoot[,1], meanRoot[,1]),2]-meanRoot[match(IndRoot[,2], meanRoot[,1]),2]

# What are the top performers (= most efficient at producing roots)?
IndRootOut <- IndRoot[which(IndRoot$Diff_mean > 0),]

# Percentage of individuals that are outperformed by P1
TopInd <- 100*(sort(table(IndRootOut[,1]), decreasing=T)/length(unique(MERGE$IndGeno)))

# Select only ind that are outperforming at least 20% of individuals 
TopInd <- TopInd[which(TopInd >= 20)]

TopInd <- as.matrix(round(TopInd, 1))
colnames(TopInd) <- c("Percentage of individuals outperformed")

# Plot table
knitr::kable(TopInd, caption = "List of individual that are outperforming at least 20% of individuals (based on Wilcoxon rank sum tests on Individual variable with a pval <= 0.01).")
```

## Clustering analyses on rooting data {.tabset .tabset-pills}

In this section, we are applying a clustering approach on callus (binary) and root (count) data to further investigate individual effects independently to treatments. We first conduct independent clustering analyses on the two variables to sort individual lines based on their abilities to promote callus development and roots. These analyses will allow identifying callus and root clusters, which will then be compared by plotting those on the respective clustering analyses. To further characterize the clusters, ridgeline plots (or density plots) will be inferred for each variable and individual lines sorted by clusters.   

### Analyses {#clustAnalyses}

Clustering analyses were performed between individual lines based on the euclidean distance and the hierarchical clustering method implemented in the R *stats* package (using the `Callus` binary and `Root` count data; see section \@ref(Rclustroot) for R code). See Figure \@ref(fig:clusterTrees) for results and those are discussed below (by variable).

```{r clusterTrees, cache = F, echo = F, eval = T, , warning = F, out.width = "100%", fig.cap="Clustering analyses based on callus (a) and root (b) data. For each variable, clusters are represented by shaded polygons, whereas the circles represent the assignment of the individual lines in the other analysis."}
####~~~~
#Clustering analyses
####~~~~

#Perform clustering analyses on callus (binary) and root (count) data
# based on euclidian distance

###
# Callus data
###
# Input data for clustering and heatmap
mat_callus <- table(MERGE$IndGeno, MERGE$Callus)

#Clustering analysis
clustCal <- hclust(dist(mat_callus))
#convert to phylo class
trCal <- as.phylo(clustCal)

#Find MRCA of clusters
#Red clade
RedNode <- getMRCA(trCal, c("G2_b5_1", "G1_b7_1"))
#Green node
GreenNode <- getMRCA(trCal, c("G2_b16_1", "G2_b17_1"))
#Orange node
OrangeNode <- getMRCA(trCal, c("G1_b10_1", "G2_b7_1"))

###
# Root data
###
# Input data for clustering and heatmap
mat_root <- table(MERGE$IndGeno, MERGE$Root)

#Clustering analysis
clustRt <- hclust(dist(mat_root))
#convert to phylo class
trRt <- as.phylo(clustRt)

#Find MRCA of clusters
#Blue clade
blueNode <- getMRCA(trRt, c("G2_b27_1", "G1_b2_1"))
#Black node
blackNode <- getMRCA(trRt, c("G2_b25_1", "G2_b26_1"))
#Pink node
pinkNode <- getMRCA(trRt, c("G2_18_1", "G1_b19_1"))

###~~~
#Matrix with clusters and tips
###~~~
#This will serve to plot and compare the clustering analyses
MatClustInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

###~~~
#Draw trees
###~~~

#Callus tree
#Add top performers
#trCal$tip.label[which(trCal$tip.label %in% rownames(TopInd))] <- c(paste(trCal$tip.label[which(trCal$tip.label %in% rownames(TopInd))][1], " P1", sep=""), paste(trCal$tip.label[which(trCal$tip.label %in% rownames(TopInd))][2], " P2", sep=""))

trCalplot <- ggtree(trCal, layout="circular", branch.length="none", color="black") + 
  geom_tiplab(aes(angle=angle), color='black', offset=.7, size = 2.2) +
  geom_hilight(node=RedNode, fill="red", alpha=.6) +
  geom_hilight(node=GreenNode, fill="green", alpha=.6) +
  geom_hilight(node=OrangeNode, fill="orange", alpha=.6) +
  geom_tippoint(color = as.character(MatClustInd[,2]), size = 3) +
  #theme(plot.margin=unit(c(6,6,6,6), "cm")) +
  xlim_tree(21)

#Root tree
#Add top performers
#trRt$tip.label[which(trRt$tip.label %in% rownames(TopInd))] <- c(paste(trRt$tip.label[which(trRt$tip.label %in% rownames(TopInd))][1], "P1", sep=""), paste(trRt$tip.label[which(trRt$tip.label %in% rownames(TopInd))][2], " P2", sep=""))

trRtplot <- ggtree(trRt, layout="circular", branch.length="none", color="black") + 
  geom_tiplab(aes(angle=angle), color='black', offset=.4, size = 2.2) +
  geom_hilight(node=blackNode, fill="black", alpha=.6) +
  geom_hilight(node=pinkNode, fill="pink", alpha=.6) +
  geom_hilight(node=blueNode, fill="blue", alpha=.6) +
  #theme(plot.margin=unit(c(6,6,6,6), "cm")) +
  geom_tippoint(color = as.character(MatClustInd[,3]), size = 3) +
  xlim_tree(11)

ggarrange(trCalplot, trRtplot,ncol = 2, nrow = 1, labels="auto")
```

To further compare the clusters identified in Figure \@ref(fig:clusterTrees) ridgeline plots (or density plots; more on this topic [here](https://www.data-to-viz.com/graph/ridgeline.html)) were inferred for each variable using the R package *ggridges*. See Figure \@ref(fig:RidgelinesClusterTrees) for the results. 

```{r RidgelinesClusterTrees, cache=F, echo=F, eval=T, out.width = "100%", fig.cap="Ridgeline plots based on callus (a) and root (b) data. For each variable, individual lines are sorted based on the clustering analysis and ridgeline plots are colored based on clusters."}

###~~~~
# Ridgeline plots
###~~~~
###~~~
#Add a new col in MERGE with order of tips based on hclust analysis
# This will help sorting individuals for ridgeline plot
###~~~

#Root data
is_tipRt <- trRt$edge[,2] <= length(trRt$tip.label)
ordered_tipsRt <- trRt$edge[is_tipRt, 2]
newtipsRt <- trRt$tip.label[ordered_tipsRt]

MERGE$ClustOrdRt <- rep("NA", nrow(MERGE))
for(i in 1:length(newtipsRt)){
  MERGE$ClustOrdRt[grep(newtipsRt[i], MERGE$IndGeno)] <- i
}
#Pad tip numbers to allow sorting them (for ridgeline plot)
MERGE$ClustOrdRt <- str_pad(MERGE$ClustOrdRt, 2, pad = "0")

#Callus data
is_tipCal <- trCal$edge[,2] <= length(trCal$tip.label)
ordered_tipsCal <- trCal$edge[is_tipCal, 2]
newtipsCal <- trCal$tip.label[ordered_tipsCal]

MERGE$ClustOrdCal <- rep("NA", nrow(MERGE))
for(i in 1:length(newtipsCal)){
  MERGE$ClustOrdCal[grep(newtipsCal[i], MERGE$IndGeno)] <- i
}
#Pad tip numbers to allow sorting them (for ridgeline plot)
MERGE$ClustOrdCal <- str_pad(MERGE$ClustOrdCal, 2, pad = "0")

###~~~
#Add clusters in MERGE: For coloring ridgeline series
###~~~
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Root_Cluster[match(MERGE$IndGeno, colInd$Individual)]
MERGE$ClusterRoot <- as.vector(MERGE$ClusterRoot)

MERGE$ClusterCallus <- colInd$Callus_Cluster[match(MERGE$IndGeno, colInd$Individual)]
MERGE$ClusterCallus <- as.vector(MERGE$ClusterCallus)

###
#Ridgeline plot
###

# Callus ridgeline
CallusRidge <- MERGE %>%
  mutate(text = fct_reorder(IndGeno, ClustOrdCal)) %>%
  ggplot(aes(x = Callus, y = text, fill = ClusterCallus)) +
  scale_fill_manual(values = c("green", "orange","red")) +
  geom_density_ridges(stat="binline", binwidth = 1) +
  xlab("Callus data (0 = absence; 1 = presence)") +
  ylab("Individual lines (by clusters)     ") +
  theme_ridges() + 
  theme(legend.position = "none", text = element_text(size = 7), axis.text.y = element_text(size = 7), axis.text.x = element_text(size = 7)) 


# Root ridgeline
RootRidge <- MERGE %>%
  mutate(text = fct_reorder(IndGeno, ClustOrdRt)) %>%
  ggplot(aes(x = Root, y = text, fill = ClusterRoot)) +
  scale_fill_manual(values = c("grey", "blue","pink")) +
  geom_density_ridges(stat="binline", binwidth = 1) +
  theme_ridges() + 
  xlab("Root data (number of roots per shoot tip)") +
  ylab("Individual lines (by clusters)     ") +
  theme(legend.position = "none", text = element_text(size = 7), axis.text.y = element_text(size = 7), axis.text.x = element_text(size = 7))  

ggarrange(CallusRidge, RootRidge, ncol = 2, nrow = 1, labels="auto")
```

#### Root data

This analysis sorted individuals into rooting clusters based on their abilities to initiate rooting (which is also shown by the ridgeline plot). Finally, to performer individuals (P1 and P2) identified by the statistical analyses are also represented on the graph. The code used to produce these analyses is available in section \@ref(Rclustroot). The analysis clearly distinguished three clusters (of even number of individuals; see Table \@ref(tab:tablegroups)) based on individual rooting performances (Figure \@ref(fig:clusterTrees)):

- Black cluster: No to very little rooting.
- Pink cluster: Some rooting observed.
- Blue cluster: Most individuals are exhibiting high rooting capacity and the top three performers belong to this cluster.

The number of individual per rooting clusters inferred from the clustering analysis is displayed in Table \@ref(tab:tablegroups). The R code to generate this table is in section \@ref(Rclustroot).

```{r tablegroups, echo=F, eval=T}
###~~~
#Produce pivot table with number of individual per group and genotype composition
###~~~
# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# colInd add Genotypes
colInd$Genotype <- sapply(strsplit(as.vector(colInd$Individual), split="_"), "[[", 1)
tabGroup <- table(colInd$Group, colInd$Genotype)
tabGroup <- tabGroup[c(1,3,2),]
tabGroup <- as.data.frame.matrix(tabGroup)
tabGroup$TOT <- rowSums(tabGroup)

# Plot table
knitr::kable(tabGroup, row.names=T, caption = "Table summarizing composition of clusters based on rooting data.")
```

##### Effect of growth regulators on *in vitro* rooting sorted by clusters

Table \@ref(tab:growthbyregulatorcluster) shows that IBA at both concentrations seem to have a significant effect on rooting for individuals belonging to the blue cluster (Figure \@ref(fig:RidgelinesClusterTrees)). Responses are very high (both at 87.18%) and the number of roots per tip are 2.97 +/- 2.25 for IBA 0.5 and 3.59 +/- 3.41 for IBA 1 (Table \@ref(tab:growthbyregulatorcluster)). The R code to generate this table is in section \@ref(Rclustroot).

```{r growthbyregulatorcluster, echo=F, eval=T}
#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
treat <- sort(unique(MERGE$Treatment))

#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatC <- matrix(ncol=6, nrow=15)
colnames(RootingStatbyTreatC) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots", "Treatment")

#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

#Convert to dataframe
RootingStatbyTreatC <- as.data.frame(RootingStatbyTreatC)

#Populate matrix
RootingStatbyTreatC$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatC$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatC$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatC$Treatment <- rep(treat, 3)

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreatC)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatC$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatC$Cluster[i])
  RootingStatbyTreatC$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep= " ")
  RootingStatbyTreatC$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}


#Plot table
knitr::kable(RootingStatbyTreatC[,1:5], row.names=F, caption = "Effect of growth regulator on in vitro rooting of Artemisia tridentata sorted by cluster. Response: mean of the three replicates +/- standard deviation; Av. No. of roots: mean +/- standard deviation.")
```

This will be investigated by looking at top performer individuals identified by i) statistical analyses and ii) clustering analysis.

#### Callus data

The code used to produce these analyses is available in section \@ref(Rclustroot). The analysis clearly distinguished three clusters based on individual lines producing callus (Figure \@ref(fig:clusterTrees)):
  
- Red cluster: Very limited callus production.
- Green cluster: Intermediate callus production.
- Orange cluster: High callus production.

The clusters from the rooting analysis are not recovered here (each callus cluster are composed by a mixture of clusters from the rooting analysis) (see Figure \@ref(fig:clusterTrees). This suggests that calli production do not inhibit rooting.

##### Effect of growth regulators on *in vitro* calli production in *Artemisia tridentata* sorted by rooting clusters

Table \@ref(tab:growthbyregulatorclustercallus) shows that IBA at both concentrations seem to have a significant effect on callus production for individuals belonging to the blue cluster (Figure \@ref(fig:clusterTrees)). The R code is available in section \@ref(Rclustroot).

```{r growthbyregulatorclustercallus, echo=F, eval=T}
###~~~
#Effect of growth regulators on calli production sorted by rooting cluster
###~~~

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Create vector of treatments
treat <- sort(unique(MERGE$Treatment))

# Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatCal <- matrix(ncol=5, nrow=15)
colnames(RootingStatbyTreatCal) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Treatment")

# Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

# Convert to dataframe
RootingStatbyTreatCal <- as.data.frame(RootingStatbyTreatCal)

# Populate matrix
RootingStatbyTreatCal$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatCal$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatCal$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatCal$Treatment <- rep(treat, 3)

# Infer Response
for(i in 1:nrow(RootingStatbyTreatCal)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatCal$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatCal$Cluster[i])
  RootingStatbyTreatCal$`Response (%)`[i] <- round(100*(mean(foo$Callus)),2)
}

#Plot table
knitr::kable(RootingStatbyTreatCal[,1:5], row.names=F, caption = "Effect of growth regulators on in vitro calli production on shoot tips of diploid Artemisia tridentata subsp. tridentata sorted by rooting clusters. Response: mean of the three replicates.")
```

### R code {#Rclustroot}

```{r codeclustRoot, echo=T, eval=F}
####~~~~
#Clustering analyses
####~~~~

#Perform clustering analyses on callus (binary) and root (count) data
# based on euclidian distance

###
# Callus data
###
# Input data for clustering and heatmap
mat_callus <- table(MERGE$IndGeno, MERGE$Callus)

#Clustering analysis
clustCal <- hclust(dist(mat_callus))
#convert to phylo class
trCal <- as.phylo(clustCal)

#Find MRCA of clusters
#Red clade
RedNode <- getMRCA(trCal, c("G2_b5_1", "G1_b7_1"))
#Green node
GreenNode <- getMRCA(trCal, c("G2_b16_1", "G2_b17_1"))
#Orange node
OrangeNode <- getMRCA(trCal, c("G1_b10_1", "G2_b7_1"))


###
# Root data
###
# Input data for clustering and heatmap
mat_root <- table(MERGE$IndGeno, MERGE$Root)

#Clustering analysis
clustRt <- hclust(dist(mat_root))
#convert to phylo class
trRt <- as.phylo(clustRt)

#Find MRCA of clusters
#Blue clade
blueNode <- getMRCA(trRt, c("G2_b27_1", "G1_b2_1"))
#Black node
blackNode <- getMRCA(trRt, c("G2_b25_1", "G2_b26_1"))
#Pink node
pinkNode <- getMRCA(trRt, c("G2_18_1", "G1_b19_1"))

###~~~
#Matrix with clusters and tips
###~~~
#This will serve to plot and compare the clustering analyses
MatClustInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

###~~~
#Draw trees
###~~~

#Callus tree
trCalplot <- ggtree(trCal, layout="circular", branch.length="none", color="black") + 
  geom_tiplab(aes(angle=angle), color='black', offset=.7, cex = 2.5) +
  geom_hilight(node=RedNode, fill="red", alpha=.6) +
  geom_hilight(node=GreenNode, fill="green", alpha=.6) +
  geom_hilight(node=OrangeNode, fill="orange", alpha=.6) +
  geom_tippoint(color = as.character(MatClustInd[,2]), size = 3) +
  xlim_tree(22)

#Root tree
trRtplot <- ggtree(trRt, layout="circular", branch.length="none", color="black") + 
  geom_tiplab(aes(angle=angle), color='black', offset=.6, cex = 2.5) +
  geom_hilight(node=blackNode, fill="black", alpha=.6) +
  geom_hilight(node=pinkNode, fill="pink", alpha=.6) +
  geom_hilight(node=blueNode, fill="blue", alpha=.6) +
  geom_tippoint(color = as.character(MatClustInd[,3]), size = 3) +
  xlim_tree(12)

ggarrange(trCalplot, trRtplot,ncol = 2, nrow = 1, labels="auto")

###~~~~
# Ridgeline plots
###~~~~
###~~~
#Add a new col in MERGE with order of tips based on hclust analysis
# This will help sorting individuals for ridgeline plot
###~~~

#Root data
is_tipRt <- trRt$edge[,2] <= length(trRt$tip.label)
ordered_tipsRt <- trRt$edge[is_tipRt, 2]
newtipsRt <- trRt$tip.label[ordered_tipsRt]

MERGE$ClustOrdRt <- rep("NA", nrow(MERGE))
for(i in 1:length(newtipsRt)){
  MERGE$ClustOrdRt[grep(newtipsRt[i], MERGE$IndGeno)] <- i
}
#Pad tip numbers to allow sorting them (for ridgeline plot)
MERGE$ClustOrdRt <- str_pad(MERGE$ClustOrdRt, 2, pad = "0")

#Callus data
is_tipCal <- trCal$edge[,2] <= length(trCal$tip.label)
ordered_tipsCal <- trCal$edge[is_tipCal, 2]
newtipsCal <- trCal$tip.label[ordered_tipsCal]

MERGE$ClustOrdCal <- rep("NA", nrow(MERGE))
for(i in 1:length(newtipsCal)){
  MERGE$ClustOrdCal[grep(newtipsCal[i], MERGE$IndGeno)] <- i
}
#Pad tip numbers to allow sorting them (for ridgeline plot)
MERGE$ClustOrdCal <- str_pad(MERGE$ClustOrdCal, 2, pad = "0")

###~~~
#Add clusters in MERGE: For coloring ridgeline series
###~~~
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Root_Cluster[match(MERGE$IndGeno, colInd$Individual)]
MERGE$ClusterRoot <- as.vector(MERGE$ClusterRoot)

MERGE$ClusterCallus <- colInd$Callus_Cluster[match(MERGE$IndGeno, colInd$Individual)]
MERGE$ClusterCallus <- as.vector(MERGE$ClusterCallus)

###
#Ridgeline plot
###

# Callus ridgeline
CallusRidge <- MERGE %>%
  mutate(text = fct_reorder(IndGeno, ClustOrdCal)) %>%
  ggplot(aes(x = Callus, y = text, fill = ClusterCallus)) +
  scale_fill_manual(values = unique(as.vector(MERGE$ClusterCallus))) +
  geom_density_ridges(stat="binline", binwidth = 1) +
  xlab("Callus data (0 = absence; 1 = presence)") +
  ylab("Individual lines (by clusters)     ") +
  theme_ridges() + 
  theme(legend.position = "none", text = element_text(size = 7), axis.text.y = element_text(size = 7)) 


# Root ridgeline
RootRidge <- MERGE %>%
  mutate(text = fct_reorder(IndGeno, ClustOrdRt)) %>%
  ggplot(aes(x = Root, y = text, fill = ClusterRoot)) +
  scale_fill_manual(values = c("grey", "blue","pink")) +
  geom_density_ridges(stat="binline", binwidth = 1) +
  theme_ridges() + 
  xlab("Root data (number of roots per shoot tip)") +
  ylab("Individual lines (by clusters)     ") +
  theme(legend.position = "none", text = element_text(size = 7), axis.text.y = element_text(size = 7)) 

ggarrange(CallusRidge, RootRidge, ncol = 2, nrow = 1, labels="auto")

###~~~
#Produce pivot table with number of individual per group and genotype composition
###~~~
# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

###~~~
#Effect of growth regulators on *in vitro* rooting sorted by clusters
###~~~
# colInd add Genotypes
colInd$Genotype <- sapply(strsplit(as.vector(colInd$Individual), split="_"), "[[", 1)
tabGroup <- table(colInd$Group, colInd$Genotype)
tabGroup <- tabGroup[c(1,3,2),]
tabGroup <- as.data.frame.matrix(tabGroup)
tabGroup$TOT <- rowSums(tabGroup)

# Plot table
knitr::kable(tabGroup, row.names=T, caption = "Table summarizing composition of clusters based on rooting data.")

#Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")
treat <- sort(unique(MERGE$Treatment))

#Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatC <- matrix(ncol=6, nrow=15)
colnames(RootingStatbyTreatC) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Av. No. of roots", "Treatment")

#Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

#Convert to dataframe
RootingStatbyTreatC <- as.data.frame(RootingStatbyTreatC)

#Populate matrix
RootingStatbyTreatC$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatC$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatC$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatC$Treatment <- rep(treat, 3)

#Infer Response and mean no roots
for(i in 1:nrow(RootingStatbyTreatC)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatC$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatC$Cluster[i])
  RootingStatbyTreatC$`Response (%)`[i] <- paste(round(100*(mean(foo$RootBin)),2), "+/-", round(sd(foo$RootBin),2), sep= " ")
  RootingStatbyTreatC$`Av. No. of roots`[i] <- paste(round(mean(foo$Root),2), "+/-", round(sd(foo$Root),2), sep=" ")
}

#Plot table
knitr::kable(RootingStatbyTreatC[,1:5], row.names=F, caption = "Effect of growth regulator on in vitro rooting of Artemisia tridentata sorted by cluster. Response: mean of the three replicates +/- standard deviation; Av. No. of roots: mean +/- standard deviation.")

###~~~
#Effect of growth regulators on calli production sorted by rooting cluster
###~~~

# Load file with color of individuals (which group based on clusters they belong to)
colInd <- read.csv("02_Processed_data/Rooting_clusters_individuals.csv")

# Create vector of treatments
treat <- sort(unique(MERGE$Treatment))

# Matrix summarizing effect of growth regulators on rooting
RootingStatbyTreatCal <- matrix(ncol=5, nrow=15)
colnames(RootingStatbyTreatCal) <- c("Cluster","Growth regulator", "Concentration (mg/l)", "Response (%)", "Treatment")

# Add col in MERGE with cluster
MERGE$ClusterRoot <- colInd$Group[match(MERGE$IndGeno, colInd$Individual)]

# Convert to dataframe
RootingStatbyTreatCal <- as.data.frame(RootingStatbyTreatCal)

# Populate matrix
RootingStatbyTreatCal$Cluster <- sort(rep(sort(unique(MERGE$ClusterRoot)),5))
RootingStatbyTreatCal$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
RootingStatbyTreatCal$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
RootingStatbyTreatCal$Treatment <- rep(treat, 3)

# Infer Response
for(i in 1:nrow(RootingStatbyTreatCal)){
  foo <- subset(MERGE, MERGE$Treatment == RootingStatbyTreatCal$Treatment[i] & MERGE$ClusterRoot == RootingStatbyTreatCal$Cluster[i])
  RootingStatbyTreatCal$`Response (%)`[i] <- round(100*(mean(foo$Callus)),2)
}

#Plot table
knitr::kable(RootingStatbyTreatCal[,1:5], row.names=F, caption = "Effect of growth regulators on in vitro calli production on shoot tips of diploid Artemisia tridentata subsp. tridentata sorted by rooting clusters. Response: mean of the three replicates.")
```

# Step 4: *In vitro* survival and growth of plantlets {#step4}

## Sampling and preliminary analyses {.tabset .tabset-pills}

### Analyses

Data on survival and plantlets heights are stored in `01_Raw_Data/Survival_height_clones.csv`. The code below provides statistics on the number of individual lines and shoot tips included in this experiment. The R code for these analyses is available in section \@ref(codesurv).

```{r statgrowth, echo=F, eval=T}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

###~~~
#How many individuals where transfered corresponding how many shoot tips
###~~~
stats <- matrix(ncol=1, nrow=4)
colnames(stats) <- "Sampling"
rownames(stats) <- c("Total N. ind.", "N. ind. per gen,","Total N. shoot tips", "N. shoot tips per gen.")

#Add N ind and N shoot tips
stats[c(1,3),] <- c(length(unique(survheig$SeedID)), sum(table(survheig$SeedID)))

#Tot ind per genotypes
totindgen <- table(sapply(strsplit(as.vector(unique(survheig$SeedID)), "_"), '[[', 1))
stats[2,1] <- paste0(paste0(names(totindgen), ":"), totindgen, collapse = '/')

#N shoot per genotypes
totgenshoot <- table(sapply(strsplit(as.vector(survheig$SeedID), "_"), '[[', 1))
stats[4,1] <- paste0(paste0(names(totgenshoot), ":"), totgenshoot, collapse = '/')


print(stats)

###~~~
#Breakdown of number of shoot tips per individual
###~~~

#Sort based on number of shoot tips
sort(table(survheig$SeedID), decreasing=T)
```

#### Survival and plantlets heights

Results of the code provided below is summarized in Table \@ref(tab:surv). After 5 weeks, a survival of 53.48% of the plantlets was observed. A significant increase of plantlets mortality has been recorded between weeks 3 and 5 and on average, plantlets did not growth significant (but see below for more details).   

```{r surv, echo=F, eval=T}
###~~~
# Matrix to store data @ 3 and 5 weeks
###~~~
survheigStat <- matrix(ncol=2, nrow = 2)
colnames(survheigStat) <- c("Survival (%)", "Plant height (cm)")
rownames(survheigStat) <- c("Week 3", "Week 5")

###
#3 weeks
###

# Survivial
ThreeWsurvAll <- table(survheig$X3_w_survival)
survheigStat[1,1] <- round(100*((sum(ThreeWsurvAll)-ThreeWsurvAll[which(names(ThreeWsurvAll) == 0)])/sum(ThreeWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[1,2] <- paste0(round(mean(survheig$X3_w_height),2), "+/-", round(sd(survheig$X3_w_height),2))

###
#5 weeks
###

# Survivial
FiveWsurvAll <- table(survheig$X5_w_survival)
survheigStat[2,1] <- round(100*((sum(FiveWsurvAll)-FiveWsurvAll[which(names(FiveWsurvAll) == 0)])/sum(FiveWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[2,2] <- paste0(round(mean(survheig$X5_w_height),2), "+/-", round(sd(survheig$X5_w_height),2))


# Plot table
knitr::kable(survheigStat, row.names=T, caption = "Survival and plantlets heights at 3 and 5 weeks (+/- standard deviations).")
```

#### Survival and plantlets heights by rooting clusters

Table \@ref(tab:survclust) shows data on survival, plantlets heights at 3 and 5 weeks sorted by rooting clusters. Data on the number of individuals and shoot tips included in this experiment for each rooting cluster is also provided. 

```{r survclust, echo=F, eval=T}
###
#Create list of clusters
###
clust <- sort(unique(survheig$Cluster))[c(1,3,2)]

###~~~
#Matrix with data on cluster, N. ind, N. shoot tips, survival and height
###~~~
clustSurvHeig <- matrix(ncol=7, nrow = length(clust))
colnames(clustSurvHeig) <- c("Rooting cluster", "N. ind.","N. shoot tips", "3 w. surv. (%)", "3 w. plant height (cm)", "5 w. surv. (%)", "5 w. plant height (cm)")
clustSurvHeig[,1] <- as.character(clust)

for(i in 1:length(clust)){
  #Subset mat to clust
  tmp <- subset(survheig, survheig$Cluster == clust[i])
  
  ###
  #3 weeks
  ###
  #N. ind.
  clustSurvHeig[i,2] <- length(unique(tmp$SeedID))
  #N. shoot tips
  clustSurvHeig[i,3] <- nrow(tmp)
  #Survivial
  ThreeWsurv <- table(tmp$X3_w_survival)
  clustSurvHeig[i,4] <- round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,5] <- paste0(round(mean(tmp$X3_w_height),2), "+/-", round(sd(tmp$X3_w_height),2))
  
  ###
  #5 weeks
  ###
  #Survivial
  FiveWsurv <- table(tmp$X5_w_survival)
  clustSurvHeig[i,6] <- round(100*((sum(FiveWsurv)-FiveWsurv[which(names(FiveWsurv) == 0)])/sum(FiveWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,7] <- paste0(round(mean(tmp$X5_w_height),2), "+/-", round(sd(tmp$X5_w_height),2))
}

#Plot table
knitr::kable(clustSurvHeig, row.names=F, caption = "Survival and plantlets heights at 3 and 5 weeks sorted by rooting clusters.")
```

#### Survival and plantlets heights by rooting clusters and treatments

Table \@ref(tab:survclusttreat) shows survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.

```{r survclusttreat, echo=F, eval=T}
###~~~
#Split survheig$Treatment to extract growth regulator and concentration
###~~~
survheig$TreatConc <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 2), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 3), sep="_")
survheig$TreatConc[grep("Control_", survheig$TreatConc)] <- "Control"

#Vector of treatments
treat <- sort(unique(survheig$TreatConc))

###~~~
#Matrix summarizing effect of growth regulators on rooting
###~~~
survheigTreat <- matrix(ncol=8, nrow=15)
colnames(survheigTreat) <- c("Cluster", "N. ind.","N. shoot tips","Growth regulator", "Concentration (mg/l)", "Survival (%)", "Height (cm)", "Treatment")

#Convert to dataframe
survheigTreat <- as.data.frame(survheigTreat)

#Populate matrix
survheigTreat$Cluster <- sort(rep(clust,5))
survheigTreat$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
survheigTreat$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
survheigTreat$Treatment <- rep(treat, 3)

#Infer N, surv and plant height
for(i in 1:nrow(survheigTreat)){
  foo <- subset(survheig, survheig$TreatConc == survheigTreat$Treatment[i] & survheig$Cluster == survheigTreat$Cluster[i])
  
  if(nrow(foo) > 0){
    #N. ind.
    survheigTreat$`N. ind.`[i] <- length(unique(foo$SeedID))
    #N. shoot tips
    survheigTreat$`N. shoot tips`[i] <- nrow(foo)
    #Survivial
    ThreeWsurv <- table(foo$X5_w_survival)
    survheigTreat$`Survival (%)`[i] <-   round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
    #Mean plant height +/- sd
    survheigTreat$`Height (cm)`[i] <- paste0(round(mean(foo$X5_w_height),2), "+/-", round(sd(foo$X5_w_height),2))  
  }
  
}

#Save to be included in manuscript
#write.csv(survheigTreat, file='Survival_cluster_treatment_5w.csv')

#Plot table
knitr::kable(survheigTreat, row.names=F, caption = "Survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.")
```

### R code {#codesurv}

```{r codesurv, echo=T, eval=F}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

###~~~
#How many individuals where transfered corresponding how many shoot tips
###~~~
stats <- matrix(ncol=1, nrow=4)
colnames(stats) <- "Sampling"
rownames(stats) <- c("Total N. ind.", "N. ind. per gen,","Total N. shoot tips", "N. shoot tips per gen.")

#Add N ind and N shoot tips
stats[c(1,3),] <- c(length(unique(survheig$SeedID)), sum(table(survheig$SeedID)))

#Tot ind per genotypes
totindgen <- table(sapply(strsplit(as.vector(unique(survheig$SeedID)), "_"), '[[', 1))
stats[2,1] <- paste0(paste0(names(totindgen), ":"), totindgen, collapse = '/')

#N shoot per genotypes
totgenshoot <- table(sapply(strsplit(as.vector(survheig$SeedID), "_"), '[[', 1))
stats[4,1] <- paste0(paste0(names(totgenshoot), ":"), totgenshoot, collapse = '/')


print(stats)

###~~~
#Breakdown of number of shoot tips per individual
###~~~

#Sort based on number of shoot tips
sort(table(survheig$SeedID), decreasing=T)

###~~~
# Matrix to store data @ 3 and 5 weeks
###~~~
survheigStat <- matrix(ncol=2, nrow = 2)
colnames(survheigStat) <- c("Survival (%)", "Plant height (cm)")
rownames(survheigStat) <- c("Week 3", "Week 5")

###
#3 weeks
###

# Survivial
ThreeWsurvAll <- table(survheig$X3_w_survival)
survheigStat[1,1] <- round(100*((sum(ThreeWsurvAll)-ThreeWsurvAll[which(names(ThreeWsurvAll) == 0)])/sum(ThreeWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[1,2] <- paste0(round(mean(survheig$X3_w_height),2), "+/-", round(sd(survheig$X3_w_height),2))

###
#5 weeks
###

# Survivial
FiveWsurvAll <- table(survheig$X5_w_survival)
survheigStat[2,1] <- round(100*((sum(FiveWsurvAll)-FiveWsurvAll[which(names(FiveWsurvAll) == 0)])/sum(FiveWsurvAll)),2)

# Mean plant height +/- sd
survheigStat[2,2] <- paste0(round(mean(survheig$X5_w_height),2), "+/-", round(sd(survheig$X5_w_height),2))


# Plot table
knitr::kable(survheigStat, row.names=T, caption = "Survival and plantlets heights at 3 and 5 weeks (+/- standard deviations).")

###
#Create list of clusters
###
clust <- sort(unique(survheig$Cluster))[c(1,3,2)]

###~~~
#Matrix with data on cluster, N. ind, N. shoot tips, survival and height
###~~~
clustSurvHeig <- matrix(ncol=7, nrow = length(clust))
colnames(clustSurvHeig) <- c("Rooting cluster", "N. ind.","N. shoot tips", "3 w. surv. (%)", "3 w. plant height (cm)", "5 w. surv. (%)", "5 w. plant height (cm)")
clustSurvHeig[,1] <- as.character(clust)

for(i in 1:length(clust)){
  #Subset mat to clust
  tmp <- subset(survheig, survheig$Cluster == clust[i])
  
  ###
  #3 weeks
  ###
  #N. ind.
  clustSurvHeig[i,2] <- length(unique(tmp$SeedID))
  #N. shoot tips
  clustSurvHeig[i,3] <- nrow(tmp)
  #Survivial
  ThreeWsurv <- table(tmp$X3_w_survival)
  clustSurvHeig[i,4] <- round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,5] <- paste0(round(mean(tmp$X3_w_height),2), "+/-", round(sd(tmp$X3_w_height),2))
  
  ###
  #5 weeks
  ###
  #Survivial
  FiveWsurv <- table(tmp$X5_w_survival)
  clustSurvHeig[i,6] <- round(100*((sum(FiveWsurv)-FiveWsurv[which(names(FiveWsurv) == 0)])/sum(FiveWsurv)),2)
  #Mean plant height +/- sd
  clustSurvHeig[i,7] <- paste0(round(mean(tmp$X5_w_height),2), "+/-", round(sd(tmp$X5_w_height),2))
}

#Plot table
knitr::kable(clustSurvHeig, row.names=F, caption = "Survival and plantlets heights at 3 and 5 weeks sorted by rooting clusters.")

###~~~
#Split survheig$Treatment to extract growth regulator and concentration
###~~~
survheig$TreatConc <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 2), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", 3), sep="_")
survheig$TreatConc[grep("Control_", survheig$TreatConc)] <- "Control"

#Vector of treatments
treat <- sort(unique(survheig$TreatConc))

###~~~
#Matrix summarizing effect of growth regulators on rooting
###~~~
survheigTreat <- matrix(ncol=8, nrow=15)
colnames(survheigTreat) <- c("Cluster", "N. ind.","N. shoot tips","Growth regulator", "Concentration (mg/l)", "Survival (%)", "Height (cm)", "Treatment")

#Convert to dataframe
survheigTreat <- as.data.frame(survheigTreat)

#Populate matrix
survheigTreat$Cluster <- sort(rep(clust,5))
survheigTreat$`Growth regulator` <- rep(sapply(strsplit(treat, split="_"),"[[",1),3)
survheigTreat$`Concentration (mg/l)` <- rep(c("-", sapply(strsplit(treat[2:length(treat)], split="_"),"[[",2)),3)
survheigTreat$Treatment <- rep(treat, 3)

#Infer N, surv and plant height
for(i in 1:nrow(survheigTreat)){
  foo <- subset(survheig, survheig$TreatConc == survheigTreat$Treatment[i] & survheig$Cluster == survheigTreat$Cluster[i])
  
  if(nrow(foo) > 0){
    #N. ind.
    survheigTreat$`N. ind.`[i] <- length(unique(foo$SeedID))
    #N. shoot tips
    survheigTreat$`N. shoot tips`[i] <- nrow(foo)
    #Survivial
    ThreeWsurv <- table(foo$X5_w_survival)
    survheigTreat$`Survival (%)`[i] <-   round(100*((sum(ThreeWsurv)-ThreeWsurv[which(names(ThreeWsurv) == 0)])/sum(ThreeWsurv)),2)
    #Mean plant height +/- sd
    survheigTreat$`Height (cm)`[i] <- paste0(round(mean(foo$X5_w_height),2), "+/-", round(sd(foo$X5_w_height),2))  
  }
  
}

#Save to be included in manuscript
#write.csv(survheigTreat, file='Survival_cluster_treatment_5w.csv')

#Plot table
knitr::kable(survheigTreat, row.names=F, caption = "Survival and plantlets heights at 5 weeks sorted by rooting clusters and treatments.")
```

## Statistical analyses on survival data {.tabset .tabset-pills}

### Analyses

Here, we will use statistical analyses to test whether treatment or individual predict survival and heights of plantlets after 5-weeks of culture. The distribution of the survival data is in Figure \@ref(fig:distrSurv) and it supports using GLM models with a binomial family distribution (same approach than with the callus data). The R code is available in section \@ref(survcodeR).

```{r survtidy, echo=F, eval=T}
####~~~~
#Infer treatment types recieved by plantles
###~~~
survheig$Treat <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(2)), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(3)), sep="_")
survheig$Treat[grep("Control_", survheig$Treat)] <- "Control"

###~~~
#Turn survival into a binary data (sickly plantlets have a score of 0.5, but will be changed to 1)
###~~~
survheig$X5_w_survival[which(survheig$X5_w_survival == 0.5)] <- 1
```

```{r distrSurv, echo=F, eval=T, fig.cap="Barplot of survival of plantlets after 5 weeks of growth."}
barplot(table(survheig$X5_w_survival), xlab="Binary data on survival", ylab="Occurrence")
```

#### Treatment effect on survival

We are using Fisher tests to test whether treatments had an effect on survivals of seedlings.

```{r fishertreatsurv, echo=F, eval=T}
###~~~
#Treatment effect on survival
##~~~
survival <- matrix(c(6, 6, 29, 12, 45, 28, 19, 40, 38, 25 ), nr=2)
colnames(survival) = c("control", "IBA_05","IBA_1","NAA_05","NAA_1")
row.names(survival) = c("live", "dead")
print (survival)

###~~~
#Fisher test
###~~~
fisher.test(survival)
```

The analysis showed that there is a treatment effect on survival.

### R code {#survcodeR}

```{r survcode, echo=T, eval=F}
####~~~~
#Infer treatment types recieved by plantles
###~~~
survheig$Treat <- paste(sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(2)), sapply(strsplit(as.vector(survheig$Treatment), split="_"), "[[", c(3)), sep="_")
survheig$Treat[grep("Control_", survheig$Treat)] <- "Control"

###~~~
#Turn survival into a binary data (sickly plantlets have a score of 0.5, but will be changed to 1)
###~~~
survheig$X5_w_survival[which(survheig$X5_w_survival == 0.5)] <- 1

###~~~
#Produce barplot of survival data
###~~~
barplot(table(survheig$X5_w_survival), xlab="Binary data on survival", ylab="Occurrence")

###~~~
#Treatment effect on survival
##~~~
survival <- matrix(c(6, 6, 29, 12, 45, 28, 19, 40, 38, 25 ), nr=2)
colnames(survival) = c("control", "IBA_05","IBA_1","NAA_05","NAA_1")
row.names(survival) = c("live", "dead")
print (survival)

###~~~
#Fisher test
###~~~
fisher.test(survival)
```


## Statistical analyses on growth data {.tabset .tabset-pills}

Here, we will only work on alive plantlets (`survheig$X5_w_survival` == 1) and conduct statistical analyses to test whether individuals from the different rooting clusters have different growth rates. First, we have to test whether the continuous growth data follow a normal distribution using the Shapiro-Wilk normality test. The R code for all these analyses is available in section \@ref(codegrowthstat).

### Analyses

#### Test for normality

```{r normgrowth, echo=F, eval=T}
###~~~
#Subset surveigh to include only alive plantlets after 5 weeks
###~~~

#All plantlets surviving after 5 weeks of culture 
subSurvHeigh <- subset(survheig, survheig$X5_w_survival != "0")

###~~~
#Test for normality
###~~~
# The data have a normal distribution!
shapiro.test(subSurvHeigh$X5_w_height)
```

#### ANOVA analyses

```{r anovaroot, echo=F, eval=T}
###~~~
#Define ANOVA model and run analysis
###~~~
#Since it seemed that treatment had an effect
anovaOUTRoot <- aov(X5_w_height ~ Cluster + SeedID, data = subSurvHeigh)


# Summary of ANOVA
summary(anovaOUTRoot)
```

The ANOVA show significant cluster and individual effects. The Tukey tests show that individuals in the blue rooting cluster are significantly taller than those in the pink cluster (black is not shown different than blue, but it could be due to small sampling size of this cluster). Finally, `G2_b27_1` is significantly taller than 13.88% of the individuals included in this experiment. This individual was identified as a top 3 performer!  

#### Tukey's tests

```{r tukeyheight, echo=F, eval=T}
###~~~
#Tukey tests on significant variables
###~~~
# Vector with significant variables (only one here)
significant_vars <- c("SeedID", "Cluster")

# Run Tukey tests
anovaOUTheight_tukey <- TukeyHSD(anovaOUTRoot, significant_vars)

# Save analysis
saveRDS(anovaOUTheight_tukey,"02_Processed_data/rds_tables/TukeyHeight.rds")

###~~~
#Investigate cluster effect (**)
###~~~
ClustTukeyHeight <- anovaOUTheight_tukey$Cluster[which(as.numeric(anovaOUTheight_tukey$Cluster[,4]) <= 0.01),]

# What are the top cluster(s) (= most efficient at growing fast)?
#ClusterTukeyHeightTop <- ClustTukeyHeight[which(ClustTukeyHeight[,1] > 0),]

print(anovaOUTheight_tukey$Cluster)
print("Blue is significantly outperforming pink!")

###~~~
#Investigate individual effect (***)
###~~~
IndTukeyHeight <- anovaOUTheight_tukey$SeedID[which(as.numeric(anovaOUTheight_tukey$SeedID[,4]) <= 0.01),]

# What are the top performers (= most efficient at growing fast)?
IndTukeyHeightTop <- IndTukeyHeight[which(IndTukeyHeight[,1] > 0),]

# Extract best performing ind (first in rownames of comparison)
P1growth <- sapply(strsplit(rownames(IndTukeyHeightTop), split='-'), "[[",1)

# Percentage of individuals that are outperformed by P1
TopIndgrowth <- 100*(sort(table(P1growth), decreasing=T)/length(unique(subSurvHeigh$SeedID)))

## This analysis shows that G2_b27_1 grows significantly faster than 14.28% of the individuals in this experiment
print(TopIndgrowth)
```

### R code {#codegrowthstat}

```{r codegrowthstatR, echo=T, eval=F}
###~~~
#Subset surveigh to include only alive plantlets after 5 weeks
###~~~

#All plantlets surviving after 5 weeks of culture 
subSurvHeigh <- subset(survheig, survheig$X5_w_survival != "0")

###~~~
#Test for normality
###~~~
# The data have a normal distribution!
shapiro.test(subSurvHeigh$X5_w_height)

###~~~
#Define ANOVA model and run analysis
###~~~
#Since it seemed that treatment had an effect
anovaOUTRoot <- aov(X5_w_height ~ Cluster + SeedID, data = subSurvHeigh)


# Summary of ANOVA
summary(anovaOUTRoot)

###~~~
#Tukey tests on significant variables
###~~~
# Vector with significant variables (only one here)
significant_vars <- c("SeedID", "Cluster")

# Run Tukey tests
anovaOUTheight_tukey <- TukeyHSD(anovaOUTRoot, significant_vars)

# Save analysis
saveRDS(anovaOUTheight_tukey,"02_Processed_data/rds_tables/TukeyHeight.rds")

###~~~
#Investigate cluster effect (**)
###~~~
ClustTukeyHeight <- anovaOUTheight_tukey$Cluster[which(as.numeric(anovaOUTheight_tukey$Cluster[,4]) <= 0.01),]

# What are the top cluster(s) (= most efficient at growing fast)?
#ClusterTukeyHeightTop <- ClustTukeyHeight[which(ClustTukeyHeight[,1] > 0),]

print(anovaOUTheight_tukey$Cluster)
print("Blue is significantly outperforming pink!")

###~~~
#Investigate individual effect (***)
###~~~
IndTukeyHeight <- anovaOUTheight_tukey$SeedID[which(as.numeric(anovaOUTheight_tukey$SeedID[,4]) <= 0.01),]

# What are the top performers (= most efficient at growing fast)?
IndTukeyHeightTop <- IndTukeyHeight[which(IndTukeyHeight[,1] > 0),]

# Extract best performing ind (first in rownames of comparison)
P1growth <- sapply(strsplit(rownames(IndTukeyHeightTop), split='-'), "[[",1)

# Percentage of individuals that are outperformed by P1
TopIndgrowth <- 100*(sort(table(P1growth), decreasing=T)/length(unique(subSurvHeigh$SeedID)))

## This analysis shows that G2_b27_1 grows significantly faster than 14.28% of the individuals in this experiment
print(TopIndgrowth)
```

## Boxplot of plantlet heights for individuals in blue rooting cluster {.tabset .tabset-pills}

### Analyses

Figure \@ref(fig:boxplotheightblue) shows the distribution of plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid *Artemisia tridentata* subsp. *tridentata*. As predicted by the statistical analyses on plantlet heights, `G2_b7_1` among the top three individuals with the fastest growth in our experiment (with `G2_b7_1` being the fastest grower and isolated as P2 in previous analyses). The top two individuals identified by the rooting analysis are also shown on the boxplot. The R code is available in section \@ref(boxgrowthcode).

```{r boxplotheightblue, echo=F, eval=T, fig.cap="Boxplot showing plantlets heights after five weeks of culture for individuals belonging to the blue rooting cluster of diploid Artemisia tridentata subsp. tridentata. The n indicates the number of plantlets cultured for each individual. The top three performers as identified by the rooting experiment are also displayed (P1, P2)."}
###~~~
#Subset to only include from blue rooting cluster
###~~~
blueHeight <- subset(subSurvHeigh, subSurvHeigh$Cluster == 'blue')

#Individual
seedID <- table(as.vector(blueHeight$SeedID))

# Create a vector named "new_order" containing the desired order to display individuals (smaller to taller)
new_order <- with(blueHeight, reorder(as.vector(blueHeight$SeedID), as.numeric(blueHeight$X5_w_height), median , na.rm=T))

# Draw boxplot
boxplot(as.numeric(blueHeight$X5_w_height) ~ new_order, names = paste(names(seedID), paste0("(n: ", as.vector(seedID), ")"), sep = "\n"), las=2, xlab = "", ylab = "Plantlet height (cm)", cex = .8)

#Add P1, P2
top <- which(names(seedID) %in% c("G2_b27_1", "G2_b7_1"))
text(x=top, y=1.8, c("P1", "P2"))
```

### R code {#boxgrowthcode}

```{r boxplotheightbluecode, echo=T, eval=F}
###~~~
#Subset to only include from blue rooting cluster
###~~~
blueHeight <- subset(subSurvHeigh, subSurvHeigh$Cluster == 'blue')

#Individual
seedID <- table(as.vector(blueHeight$SeedID))

# Create a vector named "new_order" containing the desired order to display individuals (smaller to taller)
new_order <- with(blueHeight, reorder(as.vector(blueHeight$SeedID), as.numeric(blueHeight$X5_w_height), median , na.rm=T))

###~~~
# Draw boxplot
###~~~
boxplot(as.numeric(blueHeight$X5_w_height) ~ new_order, names = paste(names(seedID), paste0("(n: ", as.vector(seedID), ")"), sep = "\n"), las=2, xlab = "", ylab = "Plantlet height (cm)", cex = .8)

#Add P1, P2
top <- which(names(seedID) %in% c("G2_b27_1", "G2_b7_1"))
text(x=top, y=1.8, c("P1", "P2"))
```

# References

<div id="refs"></div>

# Appendix 1 {.appendix}

Citations of all R packages used to generate this report. 

```{r generateBibliography, eval = T, results="asis", cache = F, echo=F, warning = FALSE, message=FALSE}
library("knitcitations")
cleanbib()
options("citation_format" = "pandoc")
read.bibtex(file = "packages.bib")
``` 

# Appendix 2 {.appendix}

Version information about R, the operating system (OS) and attached or R loaded packages. This appendix was generated using `sessionInfo()`.

```{r eval=T, echo=F, warning = FALSE, message=FALSE}
sessionInfo()
```

# Appendix 3 {.appendix}

Tissue culture data at the basis of analyses presented in step 3.

```{r tidy, echo=F}
DT::datatable(MERGE, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
#knitr::kable(MERGE, caption = "Sampling at the basis of the sagebrush rooting experiment.")
```

# Appendix 4 {.appendix}

*In vitro* survival and growth data for plantlets at the basis of analyses presented in step 4.

```{r survgrowthappendix, echo=F}
###~~~
#Load data on survival and height
###~~~
survheig <- read.csv("01_Raw_Data/Survival_height_clones.csv")

DT::datatable(survheig[,c(4,5,8,9,10,11)], extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
#knitr::kable(MERGE, caption = "Sampling at the basis of the sagebrush rooting experiment.")
```

